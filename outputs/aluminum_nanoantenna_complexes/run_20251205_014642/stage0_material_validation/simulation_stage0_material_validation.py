#!/usr/bin/env python3
"""
Stage: stage0_material_validation
Target: Fig. 2a (TDBC absorption spectrum)
Description: Analytical material property validation for aluminum nanodisk/TDBC
             strong coupling study. Computes ε(ω), n(ω), k(ω) for all materials.
Generated by: CodeGeneratorAgent
"""

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import json
import os

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"])
# ═══════════════════════════════════════════════════════════════════════

# Characteristic length - READ FROM DESIGN
a_unit = 1e-6  # 1 µm = 1e-6 m (from design.unit_system.characteristic_length_m)

print(f"=== Stage 0: Material Validation ===")
print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"Unit system: a_unit = {a_unit} m ({a_unit*1e6:.1f} µm)")

# ═══════════════════════════════════════════════════════════════════════
# PHYSICAL CONSTANTS
# ═══════════════════════════════════════════════════════════════════════

c = 2.998e8          # Speed of light (m/s)
hbar = 1.0546e-34    # Reduced Planck constant (J·s)
hbar_eV = 6.582e-16  # Reduced Planck constant (eV·s)
eV_to_J = 1.602e-19  # eV to Joules conversion

# ═══════════════════════════════════════════════════════════════════════
# WAVELENGTH/ENERGY GRID
# ═══════════════════════════════════════════════════════════════════════

# Wavelength range: 400-800 nm (as specified in design)
wl_nm = np.linspace(400, 800, 401)  # 401 points for good resolution
wl_m = wl_nm * 1e-9  # Convert to meters

# Angular frequency (rad/s)
omega = 2 * np.pi * c / wl_m

# Energy in eV: E = ℏω
energy_eV = hbar_eV * omega

print(f"\nWavelength range: {wl_nm[0]:.0f} - {wl_nm[-1]:.0f} nm")
print(f"Energy range: {energy_eV[-1]:.3f} - {energy_eV[0]:.3f} eV")
print(f"Number of points: {len(wl_nm)}")

# ═══════════════════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════

def epsilon_to_nk(epsilon):
    """Convert complex permittivity to refractive index n and extinction k."""
    # ε = (n + ik)² → n + ik = sqrt(ε)
    sqrt_eps = np.sqrt(epsilon.astype(complex))
    n = np.real(sqrt_eps)
    k = np.imag(sqrt_eps)
    return n, k

def absorption_coefficient(k, wavelength_m):
    """Calculate absorption coefficient α = 4πk/λ (in m⁻¹)."""
    return 4 * np.pi * k / wavelength_m

def find_fwhm(x, y):
    """Find FWHM of a peak in data (x, y)."""
    y_max = np.max(y)
    y_half = y_max / 2
    
    # Find indices where y crosses half-maximum
    above_half = y > y_half
    # Find first and last crossings
    diff = np.diff(above_half.astype(int))
    rise_idx = np.where(diff == 1)[0]
    fall_idx = np.where(diff == -1)[0]
    
    if len(rise_idx) > 0 and len(fall_idx) > 0:
        # Interpolate for better accuracy
        idx1 = rise_idx[0]
        idx2 = fall_idx[-1]
        
        # Linear interpolation at half-max crossings
        x1 = x[idx1] + (y_half - y[idx1]) / (y[idx1+1] - y[idx1]) * (x[idx1+1] - x[idx1])
        x2 = x[idx2] + (y_half - y[idx2]) / (y[idx2+1] - y[idx2]) * (x[idx2+1] - x[idx2])
        
        fwhm = abs(x2 - x1)
        x_peak = x[np.argmax(y)]
        return fwhm, x_peak, y_max
    else:
        return None, x[np.argmax(y)], y_max

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 1: ALUMINUM (Drude-Lorentz from Palik)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Computing Aluminum (Palik) optical properties ---")

# Parameters from design specification (fitted to Palik data)
# Drude term: ε_Drude = -ωp²/(ω² + iωγ)
# Lorentz term (interband): ε_L = σ·ω0²/(ω0² - ω² - iωγ)

Al_eps_inf = 1.0  # High-frequency permittivity

# Drude parameters (from design)
Al_omega_p = 2.24e16  # Plasma frequency (rad/s)
Al_gamma_d = 1.22e14  # Drude damping (rad/s)

# Lorentz (interband) parameters (from design)
Al_omega_0_L = 2.27e15  # Interband transition frequency (~1.5 eV)
Al_gamma_L = 4.48e14    # Interband damping (rad/s)
Al_sigma_L = 3.57       # Oscillator strength

# Compute Drude contribution
eps_drude = -Al_omega_p**2 / (omega**2 + 1j * omega * Al_gamma_d)

# Compute Lorentz contribution (interband)
eps_lorentz = Al_sigma_L * Al_omega_0_L**2 / (Al_omega_0_L**2 - omega**2 - 1j * omega * Al_gamma_L)

# Total permittivity
eps_Al = Al_eps_inf + eps_drude + eps_lorentz

# Compute n and k
n_Al, k_Al = epsilon_to_nk(eps_Al)

print(f"  Drude plasma frequency: {Al_omega_p:.2e} rad/s ({hbar_eV * Al_omega_p:.2f} eV)")
print(f"  Interband transition: {Al_omega_0_L:.2e} rad/s ({hbar_eV * Al_omega_0_L:.2f} eV = {2*np.pi*c/(Al_omega_0_L)*1e9:.0f} nm)")
print(f"  Re(ε) range: {np.real(eps_Al).min():.1f} to {np.real(eps_Al).max():.1f}")
print(f"  Im(ε) range: {np.imag(eps_Al).min():.1f} to {np.imag(eps_Al).max():.1f}")

# Verify metallic behavior: Re(ε) < 0 in visible
metallic_range = wl_nm[np.real(eps_Al) < 0]
if len(metallic_range) > 0:
    print(f"  ✓ Metallic (Re(ε)<0) from {metallic_range[0]:.0f} to {metallic_range[-1]:.0f} nm")
else:
    print(f"  ⚠ WARNING: Re(ε) never negative - check Drude parameters!")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 2: TDBC J-AGGREGATE (Lorentzian)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Computing TDBC J-aggregate optical properties ---")

# Parameters from paper Methods section (EXACT values)
TDBC_eps_inf = 2.56     # Background permittivity
TDBC_omega_0 = 3.22e15  # Resonance frequency (rad/s) = 2.12 eV
TDBC_gamma = 2.45e13    # Homogeneous damping (rad/s)
TDBC_f = 0.45           # Oscillator strength

# Lorentzian susceptibility: Δε = f·ω0²/(ω0² - ω² - iωγ)
eps_TDBC_osc = TDBC_f * TDBC_omega_0**2 / (TDBC_omega_0**2 - omega**2 - 1j * omega * TDBC_gamma)
eps_TDBC = TDBC_eps_inf + eps_TDBC_osc

# Compute n and k
n_TDBC, k_TDBC = epsilon_to_nk(eps_TDBC)

# Absorption coefficient
alpha_TDBC = absorption_coefficient(k_TDBC, wl_m)

# Convert to more useful units (cm⁻¹)
alpha_TDBC_cm = alpha_TDBC * 1e-2  # m⁻¹ to cm⁻¹

# Key parameters in eV
TDBC_E0_eV = hbar_eV * TDBC_omega_0
TDBC_gamma_eV = hbar_eV * TDBC_gamma
TDBC_FWHM_theory_eV = 2 * TDBC_gamma_eV  # Lorentzian FWHM = 2γ

print(f"  ε∞ = {TDBC_eps_inf}")
print(f"  Resonance: ω0 = {TDBC_omega_0:.2e} rad/s = {TDBC_E0_eV:.3f} eV = {2*np.pi*c/TDBC_omega_0*1e9:.1f} nm")
print(f"  Damping: γ = {TDBC_gamma:.2e} rad/s = {TDBC_gamma_eV:.4f} eV")
print(f"  Theory FWHM (2γ): {TDBC_FWHM_theory_eV:.4f} eV")
print(f"  Oscillator strength: f = {TDBC_f}")

# Measure actual FWHM from absorption spectrum
fwhm_result = find_fwhm(energy_eV[::-1], np.imag(eps_TDBC)[::-1])  # Reverse for increasing energy
if fwhm_result[0] is not None:
    measured_FWHM_eV = fwhm_result[0]
    peak_E_eV = fwhm_result[1]
    print(f"  Measured FWHM from Im(ε): {measured_FWHM_eV:.4f} eV")
    print(f"  Peak position: {peak_E_eV:.3f} eV")
else:
    measured_FWHM_eV = TDBC_FWHM_theory_eV
    peak_E_eV = TDBC_E0_eV
    print(f"  Could not measure FWHM, using theory value")

# CRITICAL: Compare to paper's stated value
paper_FWHM_eV = 0.066  # From paper text
print(f"\n  ⚠ LINEWIDTH DISCREPANCY:")
print(f"     Model FWHM:  {TDBC_FWHM_theory_eV:.4f} eV")
print(f"     Paper states: {paper_FWHM_eV:.3f} eV")
print(f"     Ratio: {paper_FWHM_eV / TDBC_FWHM_theory_eV:.2f}x")
print(f"     This difference likely due to inhomogeneous broadening in experiment")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 3: ITO (From Sopra database or fallback)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Computing ITO optical properties ---")

ito_data_file = "materials/ito_sopra.csv"
ito_from_file = False

# Try to load Sopra data
if os.path.exists(ito_data_file):
    print(f"  Loading ITO data from: {ito_data_file}")
    try:
        # Assume CSV format: wavelength_nm, n, k or wavelength_nm, eps_real, eps_imag
        ito_raw = np.loadtxt(ito_data_file, delimiter=',', skiprows=1)
        
        if ito_raw.shape[1] >= 3:
            ito_wl_data = ito_raw[:, 0]
            # Check if data is n,k or epsilon
            if np.all(ito_raw[:, 1] > 0) and np.all(ito_raw[:, 1] < 10):
                # Likely n, k format
                n_ito_data = ito_raw[:, 1]
                k_ito_data = ito_raw[:, 2]
                # Convert to epsilon
                eps_ito_data = (n_ito_data + 1j * k_ito_data)**2
            else:
                # Likely epsilon format
                eps_ito_data = ito_raw[:, 1] + 1j * ito_raw[:, 2]
            
            # Interpolate to our wavelength grid
            eps_ITO_real = np.interp(wl_nm, ito_wl_data, np.real(eps_ito_data))
            eps_ITO_imag = np.interp(wl_nm, ito_wl_data, np.imag(eps_ito_data))
            eps_ITO = eps_ITO_real + 1j * eps_ITO_imag
            ito_from_file = True
            print(f"  ✓ Loaded {len(ito_wl_data)} data points, interpolated to {len(wl_nm)} points")
    except Exception as e:
        print(f"  ⚠ Error loading ITO data: {e}")
        ito_from_file = False

if not ito_from_file:
    print(f"  ITO data file not found or invalid, using typical Drude model")
    # Typical ITO Drude parameters (from design fallback)
    ITO_eps_inf = 4.0
    ITO_omega_p = 2.0e15  # rad/s
    ITO_gamma = 1.5e14    # rad/s
    
    eps_ITO = ITO_eps_inf - ITO_omega_p**2 / (omega**2 + 1j * omega * ITO_gamma)
    print(f"  Using: ε∞={ITO_eps_inf}, ωp={ITO_omega_p:.1e} rad/s, γ={ITO_gamma:.1e} rad/s")

# Compute n and k for ITO
n_ITO, k_ITO = epsilon_to_nk(eps_ITO)

print(f"  n range: {n_ITO.min():.2f} to {n_ITO.max():.2f}")
print(f"  k range: {k_ITO.min():.4f} to {k_ITO.max():.4f}")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 4: GLASS (Constant n=1.51)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Glass substrate (constant) ---")

glass_n = 1.51
glass_epsilon = glass_n**2  # ε = n² for non-absorbing material

# Arrays for consistency
eps_glass = np.full_like(wl_nm, glass_epsilon, dtype=complex)
n_glass = np.full_like(wl_nm, glass_n)
k_glass = np.zeros_like(wl_nm)

print(f"  n = {glass_n} (constant)")
print(f"  ε = {glass_epsilon:.4f}")

# ═══════════════════════════════════════════════════════════════════════
# SAVE DATA FILES
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Saving data files ---")

# Create output directory if needed
os.makedirs('.', exist_ok=True)

# 1. Aluminum data
al_header = f"""# Stage: stage0_material_validation
# Material: Aluminum (Palik Drude-Lorentz fit)
# Generated: {datetime.now().isoformat()}
# Parameters: eps_inf={Al_eps_inf}, omega_p={Al_omega_p:.2e}, gamma_d={Al_gamma_d:.2e}
#             omega_0_L={Al_omega_0_L:.2e}, gamma_L={Al_gamma_L:.2e}, sigma_L={Al_sigma_L}
# Columns: wavelength_nm, energy_eV, epsilon_real, epsilon_imag, n, k
"""
al_data = np.column_stack([wl_nm, energy_eV, np.real(eps_Al), np.imag(eps_Al), n_Al, k_Al])
np.savetxt('stage0_aluminum_epsilon.csv', al_data, header=al_header, delimiter=',', 
           fmt='%.6f', comments='')
print(f"  Saved: stage0_aluminum_epsilon.csv")

# 2. TDBC data
tdbc_header = f"""# Stage: stage0_material_validation
# Material: TDBC J-aggregate (Lorentzian model)
# Generated: {datetime.now().isoformat()}
# Parameters: eps_inf={TDBC_eps_inf}, omega_0={TDBC_omega_0:.2e} rad/s ({TDBC_E0_eV:.3f} eV)
#             gamma={TDBC_gamma:.2e} rad/s ({TDBC_gamma_eV:.4f} eV), f={TDBC_f}
# Theory FWHM: {TDBC_FWHM_theory_eV:.4f} eV (Paper states: {paper_FWHM_eV} eV)
# Columns: wavelength_nm, energy_eV, epsilon_real, epsilon_imag, n, k, absorption_coefficient_cm
"""
tdbc_data = np.column_stack([wl_nm, energy_eV, np.real(eps_TDBC), np.imag(eps_TDBC), 
                             n_TDBC, k_TDBC, alpha_TDBC_cm])
np.savetxt('stage0_tdbc_epsilon.csv', tdbc_data, header=tdbc_header, delimiter=',',
           fmt='%.6f', comments='')
print(f"  Saved: stage0_tdbc_epsilon.csv")

# 3. ITO data
ito_source = "Sopra database" if ito_from_file else "Drude model (fallback)"
ito_header = f"""# Stage: stage0_material_validation  
# Material: ITO (Indium Tin Oxide)
# Source: {ito_source}
# Generated: {datetime.now().isoformat()}
# Columns: wavelength_nm, energy_eV, epsilon_real, epsilon_imag, n, k
"""
ito_data = np.column_stack([wl_nm, energy_eV, np.real(eps_ITO), np.imag(eps_ITO), n_ITO, k_ITO])
np.savetxt('stage0_ito_epsilon.csv', ito_data, header=ito_header, delimiter=',',
           fmt='%.6f', comments='')
print(f"  Saved: stage0_ito_epsilon.csv")

# 4. Glass data
glass_header = f"""# Stage: stage0_material_validation
# Material: Glass substrate (BK7-like)
# Generated: {datetime.now().isoformat()}
# Parameters: n={glass_n} (constant, non-dispersive)
# Columns: wavelength_nm, epsilon_real, epsilon_imag, n, k
"""
glass_data = np.column_stack([wl_nm, np.real(eps_glass), np.imag(eps_glass), n_glass, k_glass])
np.savetxt('stage0_glass_epsilon.csv', glass_data, header=glass_header, delimiter=',',
           fmt='%.6f', comments='')
print(f"  Saved: stage0_glass_epsilon.csv")

# ═══════════════════════════════════════════════════════════════════════
# FIGURE 1: TDBC ABSORPTION (Compare to Fig. 2a)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Generating plots ---")

fig1, ax1 = plt.subplots(figsize=(8, 6))

# Plot Im(ε) as proxy for absorption (proportional to absorption)
ax1.plot(energy_eV, np.imag(eps_TDBC), 'b-', linewidth=2, label='Im(ε) - TDBC Lorentzian')

# Mark the peak and FWHM
peak_idx = np.argmax(np.imag(eps_TDBC))
peak_E = energy_eV[peak_idx]
peak_val = np.imag(eps_TDBC)[peak_idx]

ax1.axvline(peak_E, color='gray', linestyle='--', alpha=0.5)
ax1.axhline(peak_val/2, color='gray', linestyle=':', alpha=0.5, label='Half maximum')

# Annotate FWHM
ax1.annotate(f'Peak: {peak_E:.3f} eV\n({2*np.pi*c/(peak_E/hbar_eV)*1e9:.1f} nm)',
             xy=(peak_E, peak_val), xytext=(peak_E + 0.2, peak_val * 0.8),
             fontsize=10, ha='left',
             arrowprops=dict(arrowstyle='->', color='black', lw=1))

ax1.annotate(f'Model FWHM: {TDBC_FWHM_theory_eV:.4f} eV\nPaper FWHM: {paper_FWHM_eV:.3f} eV',
             xy=(0.95, 0.95), xycoords='axes fraction',
             fontsize=10, ha='right', va='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

ax1.set_xlabel('Energy (eV)', fontsize=12)
ax1.set_ylabel('Im(ε)', fontsize=12)
ax1.set_title('Stage 0 – TDBC Absorption Spectrum – Target: Fig. 2a', fontsize=12)
ax1.set_xlim(1.5, 3.0)
ax1.legend(loc='upper left')
ax1.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('stage0_fig2a_tdbc_absorption.png', dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: stage0_fig2a_tdbc_absorption.png")

# ═══════════════════════════════════════════════════════════════════════
# FIGURE 2: ALUMINUM PERMITTIVITY
# ═══════════════════════════════════════════════════════════════════════

fig2, (ax2a, ax2b) = plt.subplots(1, 2, figsize=(12, 5))

# Left: Real part of epsilon
ax2a.plot(energy_eV, np.real(eps_Al), 'b-', linewidth=2, label='Re(ε)')
ax2a.axhline(0, color='k', linestyle='-', linewidth=0.5)
ax2a.set_xlabel('Energy (eV)', fontsize=12)
ax2a.set_ylabel('Re(ε)', fontsize=12)
ax2a.set_title('Aluminum Re(ε) - Metallic behavior', fontsize=12)
ax2a.set_xlim(1.5, 3.1)
ax2a.legend()
ax2a.grid(True, alpha=0.3)

# Mark interband transition
interband_E = hbar_eV * Al_omega_0_L
ax2a.axvline(interband_E, color='r', linestyle='--', alpha=0.5, label=f'Interband ~{interband_E:.2f} eV')

# Right: Imaginary part
ax2b.plot(energy_eV, np.imag(eps_Al), 'r-', linewidth=2, label='Im(ε)')
ax2b.set_xlabel('Energy (eV)', fontsize=12)
ax2b.set_ylabel('Im(ε)', fontsize=12)
ax2b.set_title('Aluminum Im(ε) - Absorption', fontsize=12)
ax2b.set_xlim(1.5, 3.1)
ax2b.legend()
ax2b.grid(True, alpha=0.3)
ax2b.axvline(interband_E, color='r', linestyle='--', alpha=0.5)

plt.suptitle('Stage 0 – Aluminum Permittivity (Palik Drude-Lorentz)', fontsize=14)
plt.tight_layout()
plt.savefig('stage0_aluminum_permittivity.png', dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: stage0_aluminum_permittivity.png")

# ═══════════════════════════════════════════════════════════════════════
# FIGURE 3: COMBINED 2x2 PANEL
# ═══════════════════════════════════════════════════════════════════════

fig3, axes = plt.subplots(2, 2, figsize=(12, 10))

# Panel (a): Aluminum ε
ax_a = axes[0, 0]
ax_a.plot(wl_nm, np.real(eps_Al), 'b-', linewidth=2, label='Re(ε)')
ax_a.plot(wl_nm, np.imag(eps_Al), 'r-', linewidth=2, label='Im(ε)')
ax_a.axhline(0, color='k', linestyle='-', linewidth=0.5)
ax_a.set_xlabel('Wavelength (nm)', fontsize=11)
ax_a.set_ylabel('Permittivity', fontsize=11)
ax_a.set_title('(a) Aluminum (Palik Drude-Lorentz)', fontsize=12)
ax_a.legend()
ax_a.grid(True, alpha=0.3)
ax_a.set_xlim(400, 800)

# Panel (b): TDBC absorption with FWHM
ax_b = axes[0, 1]
ax_b.plot(energy_eV, np.imag(eps_TDBC), 'b-', linewidth=2)
ax_b.axhline(peak_val/2, color='gray', linestyle=':', alpha=0.7)

# Draw FWHM bracket
half_max_level = peak_val / 2
# Find crossings
above = np.imag(eps_TDBC) > half_max_level
crossings = np.where(np.diff(above.astype(int)))[0]
if len(crossings) >= 2:
    E_left = energy_eV[crossings[0]]
    E_right = energy_eV[crossings[-1]]
    ax_b.annotate('', xy=(E_left, half_max_level), xytext=(E_right, half_max_level),
                  arrowprops=dict(arrowstyle='<->', color='red', lw=2))
    ax_b.text((E_left + E_right)/2, half_max_level * 1.1, 
              f'FWHM = {TDBC_FWHM_theory_eV:.4f} eV\n(Paper: {paper_FWHM_eV} eV)',
              ha='center', fontsize=10, color='red')

ax_b.set_xlabel('Energy (eV)', fontsize=11)
ax_b.set_ylabel('Im(ε)', fontsize=11)
ax_b.set_title('(b) TDBC Absorption – Target: Fig. 2a', fontsize=12)
ax_b.set_xlim(1.8, 2.5)
ax_b.grid(True, alpha=0.3)

# Panel (c): ITO n and k
ax_c = axes[1, 0]
ax_c.plot(wl_nm, n_ITO, 'b-', linewidth=2, label='n')
ax_c.plot(wl_nm, k_ITO, 'r-', linewidth=2, label='k')
ax_c.set_xlabel('Wavelength (nm)', fontsize=11)
ax_c.set_ylabel('Optical constants', fontsize=11)
ito_title = '(c) ITO (Sopra data)' if ito_from_file else '(c) ITO (Drude model fallback)'
ax_c.set_title(ito_title, fontsize=12)
ax_c.legend()
ax_c.grid(True, alpha=0.3)
ax_c.set_xlim(400, 800)

# Panel (d): Summary table
ax_d = axes[1, 1]
ax_d.axis('off')

# Create summary text
summary_text = """
MATERIAL PARAMETERS SUMMARY
═══════════════════════════════════════════

ALUMINUM (Palik Drude-Lorentz):
  • ε∞ = 1.0
  • ωp = 2.24×10¹⁶ rad/s (14.7 eV)
  • γ_Drude = 1.22×10¹⁴ rad/s
  • Interband: ω₀ = 2.27×10¹⁵ rad/s (~1.5 eV)
  • Re(ε) < 0 throughout visible ✓

TDBC J-AGGREGATE (Lorentzian):
  • ε∞ = 2.56
  • ω₀ = 3.22×10¹⁵ rad/s (2.12 eV, 585 nm)
  • γ = 2.45×10¹³ rad/s (0.016 eV)
  • f = 0.45 (oscillator strength)
  • Model FWHM = 0.032 eV
  • ⚠ Paper FWHM = 0.066 eV (2× larger!)

ITO:
  • Source: """ + ("Sopra database" if ito_from_file else "Drude model fallback") + f"""
  • n ≈ {n_ITO.mean():.2f} (visible average)
  • k ≈ {k_ITO.mean():.4f} (low absorption)

GLASS:
  • n = 1.51 (constant)
  • k = 0 (transparent)
"""

ax_d.text(0.05, 0.95, summary_text, transform=ax_d.transAxes, fontsize=10,
          verticalalignment='top', fontfamily='monospace',
          bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8))

plt.suptitle('Stage 0 – Material Validation Summary', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('stage0_materials_validation.png', dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: stage0_materials_validation.png")

# ═══════════════════════════════════════════════════════════════════════
# VALIDATION CHECKS
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "="*60)
print("MATERIAL VALIDATION RESULTS")
print("="*60)

validation_results = {
    "aluminum": {
        "metallic_in_visible": bool(np.all(np.real(eps_Al[wl_nm < 700]) < 0)),
        "re_eps_range": [float(np.real(eps_Al).min()), float(np.real(eps_Al).max())],
        "im_eps_range": [float(np.imag(eps_Al).min()), float(np.imag(eps_Al).max())],
        "interband_eV": float(hbar_eV * Al_omega_0_L)
    },
    "tdbc": {
        "peak_energy_eV": float(peak_E),
        "peak_wavelength_nm": float(2 * np.pi * c / (peak_E / hbar_eV) * 1e9),
        "model_fwhm_eV": float(TDBC_FWHM_theory_eV),
        "paper_fwhm_eV": float(paper_FWHM_eV),
        "fwhm_ratio": float(paper_FWHM_eV / TDBC_FWHM_theory_eV),
        "oscillator_strength": float(TDBC_f)
    },
    "ito": {
        "data_source": "sopra" if ito_from_file else "drude_fallback",
        "n_average": float(n_ITO.mean()),
        "k_average": float(k_ITO.mean())
    },
    "glass": {
        "n": float(glass_n),
        "epsilon": float(glass_epsilon)
    }
}

# Print validation summary
print("\n1. ALUMINUM:")
print(f"   ✓ Metallic (Re(ε)<0 in visible): {validation_results['aluminum']['metallic_in_visible']}")
print(f"   Re(ε) range: {validation_results['aluminum']['re_eps_range'][0]:.1f} to {validation_results['aluminum']['re_eps_range'][1]:.1f}")
print(f"   Interband transition: {validation_results['aluminum']['interband_eV']:.2f} eV")

print("\n2. TDBC:")
print(f"   Peak energy: {validation_results['tdbc']['peak_energy_eV']:.3f} eV ({validation_results['tdbc']['peak_wavelength_nm']:.1f} nm)")
print(f"   Expected: 2.1 eV (590 nm) from paper")
peak_error = abs(validation_results['tdbc']['peak_energy_eV'] - 2.1) / 2.1 * 100
if peak_error < 5:
    print(f"   ✓ Peak position within 5% of expected ({peak_error:.1f}% error)")
else:
    print(f"   ⚠ Peak position error: {peak_error:.1f}%")

print(f"\n   ⚠ LINEWIDTH DISCREPANCY (CRITICAL):")
print(f"      Model FWHM:  {validation_results['tdbc']['model_fwhm_eV']:.4f} eV")
print(f"      Paper FWHM:  {validation_results['tdbc']['paper_fwhm_eV']:.3f} eV")
print(f"      Ratio: {validation_results['tdbc']['fwhm_ratio']:.2f}x")
print(f"      This is expected: model uses homogeneous broadening only,")
print(f"      while paper value includes inhomogeneous broadening.")

print("\n3. ITO:")
print(f"   Source: {validation_results['ito']['data_source']}")
print(f"   Average n: {validation_results['ito']['n_average']:.2f}")
if 1.5 < validation_results['ito']['n_average'] < 2.5:
    print(f"   ✓ n in expected range for ITO")

print("\n4. GLASS:")
print(f"   n = {validation_results['glass']['n']:.2f}")
print(f"   ✓ Matches paper specification (n=1.51)")

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

end_time = datetime.now()
print(f"\nCompleted at: {end_time.strftime('%Y-%m-%d %H:%M:%S')}")

result_summary = {
    "status": "completed",
    "stage_id": "stage0_material_validation",
    "output_files": {
        "data": [
            "stage0_aluminum_epsilon.csv",
            "stage0_tdbc_epsilon.csv", 
            "stage0_ito_epsilon.csv",
            "stage0_glass_epsilon.csv"
        ],
        "plots": [
            "stage0_fig2a_tdbc_absorption.png",
            "stage0_aluminum_permittivity.png",
            "stage0_materials_validation.png"
        ]
    },
    "key_results": {
        "aluminum_metallic": validation_results["aluminum"]["metallic_in_visible"],
        "aluminum_interband_eV": validation_results["aluminum"]["interband_eV"],
        "tdbc_peak_eV": validation_results["tdbc"]["peak_energy_eV"],
        "tdbc_peak_nm": validation_results["tdbc"]["peak_wavelength_nm"],
        "tdbc_model_fwhm_eV": validation_results["tdbc"]["model_fwhm_eV"],
        "tdbc_paper_fwhm_eV": validation_results["tdbc"]["paper_fwhm_eV"],
        "tdbc_fwhm_ratio": validation_results["tdbc"]["fwhm_ratio"],
        "ito_source": validation_results["ito"]["data_source"],
        "ito_n_avg": validation_results["ito"]["n_average"],
        "glass_n": validation_results["glass"]["n"]
    },
    "validation_status": {
        "aluminum": "PASS" if validation_results["aluminum"]["metallic_in_visible"] else "FAIL",
        "tdbc_peak": "PASS" if abs(validation_results["tdbc"]["peak_energy_eV"] - 2.1) < 0.1 else "FAIL",
        "tdbc_linewidth": "WARNING - model 2x narrower than paper",
        "ito": "PASS" if 1.5 < validation_results["ito"]["n_average"] < 2.5 else "WARNING",
        "glass": "PASS"
    },
    "warnings": [
        "TDBC linewidth discrepancy: model FWHM (0.032 eV) is ~2x smaller than paper (0.066 eV)",
        "This is expected - paper value includes inhomogeneous broadening not in Lorentzian model"
    ],
    "requires_user_confirmation": True,
    "meep_version": "N/A - analytical calculation only"
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)
