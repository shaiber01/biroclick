#!/usr/bin/env python3
"""
Stage: stage1_bare_disk
Target: Fig 2b - Bare Al nanodisk transmission spectrum and near-field
Description: 3D FDTD simulation of bare aluminum nanodisk (D=140nm, h=40nm) 
             on ITO-coated glass substrate in periodic array configuration.
Generated by: CodeGeneratorAgent
"""

import meep as mp
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import json
import time

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"] - MUST MATCH DESIGN)
# ═══════════════════════════════════════════════════════════════════════

a_unit = 1e-6  # characteristic length: 1 µm (from design specification)

print("=" * 70)
print("STAGE 1: BARE ALUMINUM NANODISK SIMULATION")
print("=" * 70)
print(f"Unit system: a_unit = {a_unit} m ({a_unit*1e6:.1f} µm)")
print(f"All Meep coordinates are in units of {a_unit*1e6:.1f} µm")
print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

start_time = time.time()

# ═══════════════════════════════════════════════════════════════════════
# SIMULATION PARAMETERS (from design specification)
# ═══════════════════════════════════════════════════════════════════════

# Cell dimensions (in Meep units = µm)
sx = 0.32  # 320 nm period in x
sy = 0.32  # 320 nm period in y
sz = 1.0   # 1000 nm in z

# Resolution
resolution = 100  # pixels per µm → 10 nm grid spacing

# PML
pml_thickness = 0.15  # 150 nm PML

# Structure dimensions
disk_radius = 0.07   # 70 nm radius (140 nm diameter)
disk_height = 0.04   # 40 nm height
disk_center_z = 0.05 # Disk center (disk from z=0.03 to z=0.07)

ito_thickness = 0.03  # 30 nm
ito_center_z = 0.015  # ITO from z=0.0 to z=0.03

glass_thickness = 0.5  # 500 nm modeled (semi-infinite)
glass_center_z = -0.25 # Glass from z=-0.5 to z=0.0

# Source parameters (wavelength in nm, converted to Meep frequency)
wl_center_nm = 530
wl_width_nm = 400
wl_min_nm = 400
wl_max_nm = 700

# Convert to Meep frequency (f = 1/λ where λ is in µm)
fcen = 1.0 / (wl_center_nm * 1e-3)  # ~1.887
fwidth = fcen * (wl_width_nm / wl_center_nm)  # Proportional width

# Frequency range for flux monitors
fmin = 1.0 / (wl_max_nm * 1e-3)  # ~1.429
fmax = 1.0 / (wl_min_nm * 1e-3)  # ~2.5
nfreq = 200  # Number of frequency points

print(f"\nSimulation parameters:")
print(f"  Cell size: {sx} x {sy} x {sz} µm ({sx*1000:.0f} x {sy*1000:.0f} x {sz*1000:.0f} nm)")
print(f"  Resolution: {resolution} pixels/µm ({1000/resolution:.1f} nm grid)")
print(f"  Total cells (with symmetry): {int(sx*resolution/2)} x {int(sy*resolution)} x {int(sz*resolution)} = {int(sx*resolution/2 * sy*resolution * sz*resolution):,}")
print(f"  Wavelength range: {wl_min_nm}-{wl_max_nm} nm")
print(f"  Frequency range: {fmin:.3f}-{fmax:.3f} (Meep units)")
print(f"  Center frequency: {fcen:.3f} (λ = {1/fcen*1000:.1f} nm)")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL DEFINITIONS (from validated materials)
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Loading materials...")

# Conversion factor: eV to Meep frequency
# E(eV) = hc/λ = 1.23984 eV·µm / λ(µm)
# f_meep = 1/λ(µm) = E(eV)/1.23984
eV_to_meep = 1.0 / 1.23984

# --- ALUMINUM (Drude-Lorentz model from design) ---
# Parameters from design specification (Palik data fit)
Al_eps_inf = 1.0

# Drude term: ωp = 14.98 eV, γ = 0.047 eV
Al_drude_wp = 14.98 * eV_to_meep  # Plasma frequency
Al_drude_gamma = 0.047 * eV_to_meep  # Damping

# Lorentz terms from design
Al_lorentz1_w0 = 0.162 * eV_to_meep
Al_lorentz1_gamma = 0.052 * eV_to_meep
Al_lorentz1_sigma = 11.396

Al_lorentz2_w0 = 1.544 * eV_to_meep
Al_lorentz2_gamma = 0.227 * eV_to_meep
Al_lorentz2_sigma = 0.384

aluminum = mp.Medium(
    epsilon=Al_eps_inf,
    E_susceptibilities=[
        mp.DrudeSusceptibility(frequency=Al_drude_wp, gamma=Al_drude_gamma, sigma=1.0),
        mp.LorentzianSusceptibility(frequency=Al_lorentz1_w0, gamma=Al_lorentz1_gamma, sigma=Al_lorentz1_sigma),
        mp.LorentzianSusceptibility(frequency=Al_lorentz2_w0, gamma=Al_lorentz2_gamma, sigma=Al_lorentz2_sigma)
    ]
)
print(f"  Aluminum: Drude-Lorentz model (ωp={14.98} eV, γ={0.047} eV + 2 Lorentz poles)")

# --- GLASS (constant n=1.51, ε=2.2801) ---
glass = mp.Medium(epsilon=2.2801)
print(f"  Glass: n = 1.51 (ε = 2.2801)")

# --- ITO (Drude model from design) ---
ITO_eps_inf = 3.8
ITO_drude_wp = 2.0 * eV_to_meep
ITO_drude_gamma = 0.15 * eV_to_meep

ito = mp.Medium(
    epsilon=ITO_eps_inf,
    E_susceptibilities=[
        mp.DrudeSusceptibility(frequency=ITO_drude_wp, gamma=ITO_drude_gamma, sigma=1.0)
    ]
)
print(f"  ITO: Drude model (ε_inf={ITO_eps_inf}, ωp={2.0} eV, γ={0.15} eV)")

# ═══════════════════════════════════════════════════════════════════════
# GEOMETRY CONSTRUCTION
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Building geometry...")

# Layer structure (from bottom to top):
# z = -0.5 to 0.0: Glass substrate
# z = 0.0 to 0.03: ITO layer
# z = 0.03 to 0.07: Al nanodisk

geometry = [
    # Glass substrate (semi-infinite, modeled as 500nm thick)
    mp.Block(
        size=mp.Vector3(sx, sy, glass_thickness),
        center=mp.Vector3(0, 0, glass_center_z),
        material=glass
    ),
    # ITO layer (30 nm)
    mp.Block(
        size=mp.Vector3(sx, sy, ito_thickness),
        center=mp.Vector3(0, 0, ito_center_z),
        material=ito
    ),
    # Aluminum nanodisk
    mp.Cylinder(
        radius=disk_radius,
        height=disk_height,
        center=mp.Vector3(0, 0, disk_center_z),
        axis=mp.Vector3(0, 0, 1),
        material=aluminum
    )
]

print(f"  Glass substrate: z = {glass_center_z - glass_thickness/2:.3f} to {glass_center_z + glass_thickness/2:.3f} µm")
print(f"  ITO layer: z = {ito_center_z - ito_thickness/2:.3f} to {ito_center_z + ito_thickness/2:.3f} µm")
print(f"  Al nanodisk: z = {disk_center_z - disk_height/2:.3f} to {disk_center_z + disk_height/2:.3f} µm")
print(f"               radius = {disk_radius*1000:.0f} nm, height = {disk_height*1000:.0f} nm")

# Verify geometry continuity
glass_top = glass_center_z + glass_thickness/2
ito_bottom = ito_center_z - ito_thickness/2
ito_top = ito_center_z + ito_thickness/2
disk_bottom = disk_center_z - disk_height/2

print(f"\n  Interface check:")
print(f"    Glass top: z = {glass_top:.3f}, ITO bottom: z = {ito_bottom:.3f} → Gap: {(ito_bottom - glass_top)*1000:.1f} nm")
print(f"    ITO top: z = {ito_top:.3f}, Disk bottom: z = {disk_bottom:.3f} → Gap: {(disk_bottom - ito_top)*1000:.1f} nm")

# ═══════════════════════════════════════════════════════════════════════
# SYMMETRY (x-mirror with phase=-1 for Ex source)
# ═══════════════════════════════════════════════════════════════════════

# Ex field is ODD under x-reflection → phase = -1
symmetries = [mp.Mirror(direction=mp.X, phase=-1)]
print(f"\n  Using x-mirror symmetry (phase=-1 for Ex polarization)")

# ═══════════════════════════════════════════════════════════════════════
# SOURCE SETUP
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Setting up source...")

src_z = 0.3  # Source position in air above disk
sources = [
    mp.Source(
        src=mp.GaussianSource(frequency=fcen, fwidth=fwidth),
        component=mp.Ex,
        center=mp.Vector3(0, 0, src_z),
        size=mp.Vector3(sx, sy, 0)  # Plane wave spanning cell
    )
]

print(f"  Gaussian source: Ex polarized")
print(f"  Position: z = {src_z} µm ({src_z*1000:.0f} nm)")
print(f"  Center wavelength: {wl_center_nm} nm (f = {fcen:.3f})")
print(f"  Bandwidth: {wl_width_nm} nm")

# ═══════════════════════════════════════════════════════════════════════
# BOUNDARY CONDITIONS
# ═══════════════════════════════════════════════════════════════════════

# Periodic in x,y (from cell size), PML in z only
pml_layers = [mp.PML(thickness=pml_thickness, direction=mp.Z)]

print(f"\n  Boundary conditions:")
print(f"    x, y: Periodic (array simulation)")
print(f"    z: PML ({pml_thickness*1000:.0f} nm thickness)")

# ═══════════════════════════════════════════════════════════════════════
# SIMULATION OBJECT
# ═══════════════════════════════════════════════════════════════════════

cell = mp.Vector3(sx, sy, sz)

sim = mp.Simulation(
    cell_size=cell,
    geometry=geometry,
    sources=sources,
    resolution=resolution,
    boundary_layers=pml_layers,
    symmetries=symmetries,
    k_point=mp.Vector3(0, 0, 0)  # Normal incidence
)

# ═══════════════════════════════════════════════════════════════════════
# FLUX MONITORS
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Adding flux monitors...")

# Monitor positions
trans_z = -0.2  # Transmission monitor in glass substrate
refl_z = 0.25   # Reflection monitor above source

# Transmission monitor
trans_region = mp.FluxRegion(
    center=mp.Vector3(0, 0, trans_z),
    size=mp.Vector3(sx, sy, 0)
)
flux_trans = sim.add_flux(fcen, fmax - fmin, nfreq, trans_region)

# Reflection monitor (weight=-1 for backward flux)
refl_region = mp.FluxRegion(
    center=mp.Vector3(0, 0, refl_z),
    size=mp.Vector3(sx, sy, 0),
    weight=-1
)
flux_refl = sim.add_flux(fcen, fmax - fmin, nfreq, refl_region)

print(f"  Transmission monitor: z = {trans_z} µm ({trans_z*1000:.0f} nm)")
print(f"  Reflection monitor: z = {refl_z} µm ({refl_z*1000:.0f} nm)")
print(f"  Frequency points: {nfreq}")

# ═══════════════════════════════════════════════════════════════════════
# DFT FIELD MONITOR (for near-field at resonance)
# ═══════════════════════════════════════════════════════════════════════

# Monitor at 10 nm above ITO (z = 0.03 + 0.01 = 0.04)
dft_z = 0.04
f_resonance = 1.0 / (530e-3)  # Expected resonance at ~530 nm

dft_region = mp.Volume(
    center=mp.Vector3(0, 0, dft_z),
    size=mp.Vector3(sx, sy, 0)
)
dft_fields = sim.add_dft_fields([mp.Ex, mp.Ey, mp.Ez], f_resonance, 0, 1, where=dft_region)

print(f"  DFT field monitor: z = {dft_z} µm ({dft_z*1000:.0f} nm, 10 nm above ITO)")
print(f"  Monitoring at λ = 530 nm (f = {f_resonance:.3f})")

# ═══════════════════════════════════════════════════════════════════════
# RUN NORMALIZATION SIMULATION (empty cell)
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("PASS 1: Empty cell normalization run")
print("=" * 70)

# Create empty simulation (just glass substrate and ITO, no disk)
geometry_empty = [
    mp.Block(
        size=mp.Vector3(sx, sy, glass_thickness),
        center=mp.Vector3(0, 0, glass_center_z),
        material=glass
    ),
    mp.Block(
        size=mp.Vector3(sx, sy, ito_thickness),
        center=mp.Vector3(0, 0, ito_center_z),
        material=ito
    )
]

sim_empty = mp.Simulation(
    cell_size=cell,
    geometry=geometry_empty,
    sources=sources,
    resolution=resolution,
    boundary_layers=pml_layers,
    symmetries=symmetries,
    k_point=mp.Vector3(0, 0, 0)
)

# Add flux monitors to empty simulation
flux_trans_empty = sim_empty.add_flux(fcen, fmax - fmin, nfreq, trans_region)
flux_refl_empty = sim_empty.add_flux(fcen, fmax - fmin, nfreq, refl_region)

# Decay point for convergence check (in glass, away from structure)
decay_point = mp.Vector3(0, 0, trans_z)

print(f"Running empty simulation until fields decay to 1e-5...")
sim_empty.run(until_after_sources=mp.stop_when_fields_decayed(50, mp.Ex, decay_point, 1e-5))

# Save empty flux data
empty_trans_flux = np.array(mp.get_fluxes(flux_trans_empty))
empty_refl_data = sim_empty.get_flux_data(flux_refl_empty)
freqs = np.array(mp.get_flux_freqs(flux_trans_empty))

print(f"Empty simulation complete. Timesteps: {sim_empty.timestep()}")

# ═══════════════════════════════════════════════════════════════════════
# RUN STRUCTURE SIMULATION
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("PASS 2: Structure simulation (with Al nanodisk)")
print("=" * 70)

# Load negative flux for reflection calculation
sim.load_minus_flux_data(flux_refl, empty_refl_data)

print(f"Running structure simulation until fields decay to 1e-5...")
sim.run(until_after_sources=mp.stop_when_fields_decayed(50, mp.Ex, decay_point, 1e-5))

print(f"Structure simulation complete. Timesteps: {sim.timestep()}")

# ═══════════════════════════════════════════════════════════════════════
# EXTRACT FLUX DATA
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Extracting flux data...")

struct_trans_flux = np.array(mp.get_fluxes(flux_trans))
struct_refl_flux = np.array(mp.get_fluxes(flux_refl))

# Calculate normalized T and R
T = struct_trans_flux / empty_trans_flux
R = -struct_refl_flux / empty_trans_flux  # Negative because of weight=-1

# Absorption from conservation
A = 1 - T - R

# Convert frequency to wavelength (nm)
wavelengths_nm = 1000 / freqs  # λ(nm) = 1000 / f(µm⁻¹)

# Filter to valid wavelength range
valid_mask = (wavelengths_nm >= wl_min_nm) & (wavelengths_nm <= wl_max_nm)
wavelengths_nm = wavelengths_nm[valid_mask]
T = T[valid_mask]
R = R[valid_mask]
A = A[valid_mask]
freqs_valid = freqs[valid_mask]

# Find resonance (minimum transmission or maximum absorption)
resonance_idx = np.argmin(T)
resonance_wl = wavelengths_nm[resonance_idx]
resonance_T = T[resonance_idx]

print(f"\n  Results:")
print(f"    Wavelength range: {wavelengths_nm.min():.1f} - {wavelengths_nm.max():.1f} nm")
print(f"    Number of points: {len(wavelengths_nm)}")
print(f"    Resonance wavelength: {resonance_wl:.1f} nm")
print(f"    Transmission at resonance: {resonance_T:.3f}")
print(f"    Reflection at resonance: {R[resonance_idx]:.3f}")
print(f"    Absorption at resonance: {A[resonance_idx]:.3f}")

# ═══════════════════════════════════════════════════════════════════════
# EXTRACT DFT FIELD DATA
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Extracting near-field data...")

# Get DFT arrays
Ex_dft = sim.get_dft_array(dft_fields, mp.Ex, 0)
Ey_dft = sim.get_dft_array(dft_fields, mp.Ey, 0)
Ez_dft = sim.get_dft_array(dft_fields, mp.Ez, 0)

# Calculate field intensity
E_intensity = np.abs(Ex_dft)**2 + np.abs(Ey_dft)**2 + np.abs(Ez_dft)**2

# Get coordinates
x_coords = np.linspace(-sx/2, sx/2, Ex_dft.shape[0])
y_coords = np.linspace(-sy/2, sy/2, Ex_dft.shape[1])

print(f"  Field array shape: {Ex_dft.shape}")
print(f"  Max |E|² enhancement: {E_intensity.max():.2f}")

# ═══════════════════════════════════════════════════════════════════════
# SAVE DATA FILES
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Saving data files...")

# Spectrum CSV
spectrum_filename = "stage1_bare_disk_transmission.csv"
header = f"""# Stage: stage1_bare_disk
# Target: Fig 2b - Bare Al nanodisk transmission spectrum
# Generated: {datetime.now().isoformat()}
# Parameters: D=140nm, h=40nm, period=320nm, ITO=30nm
# Unit system: a_unit = 1 µm
# Resonance wavelength: {resonance_wl:.1f} nm
# Columns: wavelength_nm, frequency_meep, transmission, reflection"""

spectrum_data = np.column_stack([wavelengths_nm, freqs_valid, T, R])
np.savetxt(spectrum_filename, spectrum_data, header=header, delimiter=',', fmt='%.6f', comments='')
print(f"  Saved: {spectrum_filename}")

# Field data NPZ
field_filename = "stage1_bare_disk_field.npz"
np.savez(field_filename,
         Ex=Ex_dft, Ey=Ey_dft, Ez=Ez_dft,
         E_intensity=E_intensity,
         x_coords=x_coords * 1000,  # Convert to nm
         y_coords=y_coords * 1000,  # Convert to nm
         wavelength_nm=530,
         z_position_nm=dft_z * 1000)
print(f"  Saved: {field_filename}")

# ═══════════════════════════════════════════════════════════════════════
# GENERATE PLOTS
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "-" * 70)
print("Generating plots...")

# --- Transmission spectrum plot ---
fig, ax = plt.subplots(figsize=(8, 6))

ax.plot(wavelengths_nm, T, 'b-', linewidth=2, label='Transmission')
ax.plot(wavelengths_nm, R, 'r--', linewidth=1.5, label='Reflection')
ax.plot(wavelengths_nm, A, 'g:', linewidth=1.5, label='Absorption')

# Mark resonance
ax.axvline(resonance_wl, color='gray', linestyle='--', alpha=0.5, label=f'Resonance: {resonance_wl:.0f} nm')
ax.axvline(530, color='orange', linestyle=':', alpha=0.5, label='Expected: 530 nm')

ax.set_xlabel('Wavelength (nm)', fontsize=12)
ax.set_ylabel('T, R, A', fontsize=12)
ax.set_title(f'Stage1 – Bare Al Nanodisk (D=140nm) Transmission – Target: Fig 2b', fontsize=11)
ax.set_xlim(wl_min_nm, wl_max_nm)
ax.set_ylim(0, 1)
ax.legend(loc='best', fontsize=10)
ax.grid(True, alpha=0.3)

# Add parameter annotation
param_text = f'D = 140 nm\nh = 40 nm\nPeriod = 320 nm\nITO = 30 nm'
ax.text(0.02, 0.98, param_text, transform=ax.transAxes, fontsize=9,
        verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

plt.tight_layout()
spectrum_plot_filename = "stage1_bare_disk_fig2b_transmission.png"
plt.savefig(spectrum_plot_filename, dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: {spectrum_plot_filename}")

# --- Field enhancement plot ---
fig, ax = plt.subplots(figsize=(7, 6))

# Convert coordinates to nm
x_nm = x_coords * 1000
y_nm = y_coords * 1000

im = ax.imshow(E_intensity.T, origin='lower', cmap='hot',
               extent=[x_nm.min(), x_nm.max(), y_nm.min(), y_nm.max()],
               aspect='equal')

# Draw disk outline
theta = np.linspace(0, 2*np.pi, 100)
disk_r_nm = disk_radius * 1000
ax.plot(disk_r_nm * np.cos(theta), disk_r_nm * np.sin(theta), 'w--', linewidth=1.5, label='Disk edge')

cbar = plt.colorbar(im, ax=ax, label='|E|² (arb. units)')
ax.set_xlabel('x (nm)', fontsize=12)
ax.set_ylabel('y (nm)', fontsize=12)
ax.set_title(f'Stage1 – Near-field at λ=530nm, z=40nm – Target: Fig 2b', fontsize=11)
ax.legend(loc='upper right', fontsize=9)

plt.tight_layout()
field_plot_filename = "stage1_field_enhancement_fig2b.png"
plt.savefig(field_plot_filename, dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: {field_plot_filename}")

# ═══════════════════════════════════════════════════════════════════════
# RUNTIME SUMMARY
# ═══════════════════════════════════════════════════════════════════════

end_time = time.time()
runtime = end_time - start_time

print("\n" + "=" * 70)
print("SIMULATION COMPLETE")
print("=" * 70)
print(f"Total runtime: {runtime:.1f} seconds ({runtime/60:.1f} minutes)")
print(f"Timesteps (empty): {sim_empty.timestep()}")
print(f"Timesteps (structure): {sim.timestep()}")

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

result_summary = {
    "status": "completed",
    "stage_id": "stage1_bare_disk",
    "output_files": {
        "data": ["stage1_bare_disk_transmission.csv", "stage1_bare_disk_field.npz"],
        "plots": ["stage1_bare_disk_fig2b_transmission.png", "stage1_field_enhancement_fig2b.png"]
    },
    "key_results": {
        "resonance_wavelength_nm": float(resonance_wl),
        "expected_resonance_nm": 530,
        "resonance_shift_nm": float(resonance_wl - 530),
        "transmission_at_resonance": float(resonance_T),
        "reflection_at_resonance": float(R[resonance_idx]),
        "absorption_at_resonance": float(A[resonance_idx]),
        "max_field_enhancement": float(E_intensity.max()),
        "wavelength_range_nm": [float(wavelengths_nm.min()), float(wavelengths_nm.max())]
    },
    "runtime_seconds": runtime,
    "timesteps_empty": int(sim_empty.timestep()),
    "timesteps_structure": int(sim.timestep()),
    "meep_version": mp.__version__ if hasattr(mp, '__version__') else "unknown"
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)
