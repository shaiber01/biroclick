#!/usr/bin/env python3
"""
Stage: stage0_material_validation
Target: Fig. 2a (TDBC absorption validation)
Description: Analytical material property validation for all materials used in 
             Hakala2017 strong coupling simulations. Validates TDBC Lorentzian model,
             Palik Aluminum data, and Sopra ITO data.
Generated by: CodeGeneratorAgent
"""

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import os
import json

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"])
# ═══════════════════════════════════════════════════════════════════════

a_unit = 1e-6  # 1 µm characteristic length (from design)
print(f"Unit system: a_unit = {a_unit} m ({a_unit*1e6:.1f} µm)")

# Physical constants
hbar = 1.054571817e-34  # J·s
eV_to_J = 1.602176634e-19  # J/eV
c = 2.998e8  # m/s

# ═══════════════════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════

def wavelength_to_energy_eV(wavelength_nm):
    """Convert wavelength (nm) to photon energy (eV)"""
    return 1239.84 / wavelength_nm

def energy_to_wavelength_nm(energy_eV):
    """Convert photon energy (eV) to wavelength (nm)"""
    return 1239.84 / energy_eV

def wavelength_to_angular_freq(wavelength_nm):
    """Convert wavelength (nm) to angular frequency (rad/s)"""
    return 2 * np.pi * c / (wavelength_nm * 1e-9)

def epsilon_to_nk(epsilon):
    """Convert complex permittivity to n and k"""
    eps_complex = np.array(epsilon, dtype=complex)
    n_complex = np.sqrt(eps_complex)
    n = np.real(n_complex)
    k = np.imag(n_complex)
    # Handle negative real part of sqrt properly
    mask = n < 0
    n[mask] = -n[mask]
    k[mask] = -k[mask]
    return n, k

print("=" * 60)
print("STAGE 0: MATERIAL VALIDATION")
print("=" * 60)
print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# ═══════════════════════════════════════════════════════════════════════
# 1. TDBC J-AGGREGATE LORENTZIAN MODEL
# ═══════════════════════════════════════════════════════════════════════

print("\n--- 1. TDBC J-aggregate (Lorentzian Model) ---")

# Paper-stated parameters
tdbc_eps_inf = 2.56                    # High-frequency permittivity
tdbc_omega_0 = 3.22e15                 # Resonance frequency (rad/s)
tdbc_gamma = 2.45e13                   # Damping rate (rad/s)
tdbc_f = 0.45                          # Oscillator strength

# Convert to eV for reporting
tdbc_omega_0_eV = hbar * tdbc_omega_0 / eV_to_J
tdbc_gamma_eV = hbar * tdbc_gamma / eV_to_J
tdbc_fwhm_from_gamma = 2 * tdbc_gamma_eV  # FWHM = 2γ in eV for Lorentzian

print(f"Parameters from paper:")
print(f"  ε∞ = {tdbc_eps_inf}")
print(f"  ω₀ = {tdbc_omega_0:.3e} rad/s = {tdbc_omega_0_eV:.4f} eV")
print(f"  γ  = {tdbc_gamma:.3e} rad/s = {tdbc_gamma_eV:.4f} eV")
print(f"  f  = {tdbc_f}")
print(f"  Computed FWHM from γ: {tdbc_fwhm_from_gamma:.4f} eV")
print(f"  Paper-stated FWHM: 0.066 eV")
print(f"  DISCREPANCY: Factor of {0.066/tdbc_fwhm_from_gamma:.2f}x")

# Wavelength range for calculations
wavelengths_nm = np.linspace(400, 800, 1000)
energies_eV = wavelength_to_energy_eV(wavelengths_nm)
omega = wavelength_to_angular_freq(wavelengths_nm)

# Lorentzian dielectric function
# ε(ω) = ε∞ + f·ω₀²/(ω₀² - ω² - iγω)
tdbc_epsilon = tdbc_eps_inf + tdbc_f * tdbc_omega_0**2 / (tdbc_omega_0**2 - omega**2 - 1j * tdbc_gamma * omega)

tdbc_eps_real = np.real(tdbc_epsilon)
tdbc_eps_imag = np.imag(tdbc_epsilon)
tdbc_n, tdbc_k = epsilon_to_nk(tdbc_epsilon)

# Absorption coefficient (proportional to Im(ε) or n*k)
# Using Im(ε) for simplicity, normalized
tdbc_absorption = tdbc_eps_imag / np.max(tdbc_eps_imag)

# Find absorption peak
peak_idx = np.argmax(tdbc_eps_imag)
peak_wavelength = wavelengths_nm[peak_idx]
peak_energy = energies_eV[peak_idx]
print(f"\nAbsorption peak found at:")
print(f"  λ = {peak_wavelength:.1f} nm")
print(f"  E = {peak_energy:.4f} eV")
print(f"  Paper states: ~2.1 eV (~590 nm)")

# Measure FWHM from computed absorption curve
half_max = np.max(tdbc_eps_imag) / 2
above_half = tdbc_eps_imag > half_max
transitions = np.diff(above_half.astype(int))
rise_idx = np.where(transitions == 1)[0]
fall_idx = np.where(transitions == -1)[0]

if len(rise_idx) > 0 and len(fall_idx) > 0:
    # Interpolate for more accurate FWHM
    wl_low = wavelengths_nm[rise_idx[0]]
    wl_high = wavelengths_nm[fall_idx[0]]
    measured_fwhm_nm = wl_high - wl_low
    # Convert to eV using derivative: dE/dλ = -1239.84/λ²
    E_low = wavelength_to_energy_eV(wl_low)
    E_high = wavelength_to_energy_eV(wl_high)
    measured_fwhm_eV = E_low - E_high  # Note: E decreases as λ increases
else:
    measured_fwhm_nm = 0
    measured_fwhm_eV = 0
    
print(f"\nMeasured FWHM from curve:")
print(f"  Δλ ≈ {measured_fwhm_nm:.1f} nm")
print(f"  ΔE ≈ {measured_fwhm_eV:.4f} eV")

# Save TDBC data
tdbc_data = np.column_stack([
    wavelengths_nm,
    energies_eV,
    tdbc_eps_real,
    tdbc_eps_imag,
    tdbc_n,
    tdbc_k,
    tdbc_absorption
])

tdbc_header = f"""# TDBC J-aggregate optical properties (Lorentzian model)
# Stage: stage0_material_validation
# Generated: {datetime.now().isoformat()}
# Model: Lorentz oscillator
# Parameters: eps_inf={tdbc_eps_inf}, omega_0={tdbc_omega_0:.3e} rad/s, gamma={tdbc_gamma:.3e} rad/s, f={tdbc_f}
# Peak energy: {peak_energy:.4f} eV, Peak wavelength: {peak_wavelength:.1f} nm
# Measured FWHM: {measured_fwhm_eV:.4f} eV (from gamma: {tdbc_fwhm_from_gamma:.4f} eV)
# wavelength_nm,energy_eV,epsilon_real,epsilon_imag,n,k,absorption_arb
"""
np.savetxt('stage0_TDBC_absorption.csv', tdbc_data, header=tdbc_header, delimiter=',', fmt='%.6f', comments='')
print(f"\nSaved: stage0_TDBC_absorption.csv")

# ═══════════════════════════════════════════════════════════════════════
# 2. ALUMINUM (PALIK TABULATED DATA)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- 2. Aluminum (Palik Data) ---")

al_data_file = 'materials/Palik_Al.csv'
al_loaded = False

# Try to load Palik Al data
if os.path.exists(al_data_file):
    try:
        # Try different delimiters and skip rows
        al_raw = np.loadtxt(al_data_file, delimiter=',', skiprows=1)
        if al_raw.shape[1] >= 3:
            al_wavelengths = al_raw[:, 0]
            # Check if data is n,k or epsilon
            if np.all(al_raw[:, 1] > 0) and al_raw.shape[1] >= 3:
                # Likely n, k format
                al_n_data = al_raw[:, 1]
                al_k_data = al_raw[:, 2]
                al_eps_real_data = al_n_data**2 - al_k_data**2
                al_eps_imag_data = 2 * al_n_data * al_k_data
            else:
                # Assume epsilon format
                al_eps_real_data = al_raw[:, 1]
                al_eps_imag_data = al_raw[:, 2]
                al_n_data, al_k_data = epsilon_to_nk(al_eps_real_data + 1j * al_eps_imag_data)
            al_loaded = True
            print(f"Loaded Palik Al data from {al_data_file}")
            print(f"  Wavelength range: {al_wavelengths.min():.1f} - {al_wavelengths.max():.1f} nm")
    except Exception as e:
        print(f"Error loading {al_data_file}: {e}")

if not al_loaded:
    # Use Drude model fallback for aluminum
    print(f"WARNING: Could not load {al_data_file}")
    print("Using Drude model approximation for aluminum")
    
    # Drude parameters for Al (approximate)
    al_eps_inf = 1.0
    al_omega_p = 15.1  # eV (plasma frequency)
    al_gamma_d = 0.6   # eV (damping)
    
    al_wavelengths = wavelengths_nm.copy()
    al_energies = wavelength_to_energy_eV(al_wavelengths)
    
    # Drude model: ε(ω) = ε∞ - ωp²/(ω² + iγω)
    # In eV: ε(E) = ε∞ - ωp²/(E² + iγE)
    al_epsilon_drude = al_eps_inf - al_omega_p**2 / (al_energies**2 + 1j * al_gamma_d * al_energies)
    
    al_eps_real_data = np.real(al_epsilon_drude)
    al_eps_imag_data = np.imag(al_epsilon_drude)
    al_n_data, al_k_data = epsilon_to_nk(al_epsilon_drude)
    
    print(f"  Drude parameters: ε∞={al_eps_inf}, ωp={al_omega_p} eV, γ={al_gamma_d} eV")

# Interpolate to common wavelength grid
al_eps_real = np.interp(wavelengths_nm, al_wavelengths, al_eps_real_data)
al_eps_imag = np.interp(wavelengths_nm, al_wavelengths, al_eps_imag_data)
al_n = np.interp(wavelengths_nm, al_wavelengths, al_n_data)
al_k = np.interp(wavelengths_nm, al_wavelengths, al_k_data)

# Verify plasmonic behavior: Re(ε) < 0
al_plasmonic = np.all(al_eps_real < 0)
print(f"\nPlasmonic behavior check (Re(ε) < 0 in visible range):")
print(f"  Re(ε) range: {al_eps_real.min():.1f} to {al_eps_real.max():.1f}")
print(f"  ALL negative in 400-800nm: {al_plasmonic}")

# Save Al data
al_data = np.column_stack([wavelengths_nm, al_eps_real, al_eps_imag, al_n, al_k])
al_header = f"""# Aluminum optical properties (Palik)
# Stage: stage0_material_validation
# Generated: {datetime.now().isoformat()}
# Source: {'Palik tabulated' if al_loaded else 'Drude model approximation'}
# Plasmonic (Re(ε)<0 in visible): {al_plasmonic}
# wavelength_nm,epsilon_real,epsilon_imag,n,k
"""
np.savetxt('stage0_Al_permittivity.csv', al_data, header=al_header, delimiter=',', fmt='%.6f', comments='')
print(f"Saved: stage0_Al_permittivity.csv")

# ═══════════════════════════════════════════════════════════════════════
# 3. ITO (SOPRA TABULATED DATA)
# ═══════════════════════════════════════════════════════════════════════

print("\n--- 3. ITO (Sopra Data) ---")

ito_data_file = 'materials/Sopra_ITO.csv'
ito_loaded = False

if os.path.exists(ito_data_file):
    try:
        ito_raw = np.loadtxt(ito_data_file, delimiter=',', skiprows=1)
        if ito_raw.shape[1] >= 3:
            ito_wavelengths = ito_raw[:, 0]
            # Assume n, k format
            ito_n_data = ito_raw[:, 1]
            ito_k_data = ito_raw[:, 2]
            ito_eps_real_data = ito_n_data**2 - ito_k_data**2
            ito_eps_imag_data = 2 * ito_n_data * ito_k_data
            ito_loaded = True
            print(f"Loaded Sopra ITO data from {ito_data_file}")
            print(f"  Wavelength range: {ito_wavelengths.min():.1f} - {ito_wavelengths.max():.1f} nm")
    except Exception as e:
        print(f"Error loading {ito_data_file}: {e}")

if not ito_loaded:
    # Use constant approximation for ITO
    print(f"WARNING: Could not load {ito_data_file}")
    print("Using constant n approximation for ITO")
    
    # Typical ITO: n ≈ 1.9, k ≈ 0.01 in visible
    ito_wavelengths = wavelengths_nm.copy()
    ito_n_data = np.ones_like(ito_wavelengths) * 1.9
    ito_k_data = np.ones_like(ito_wavelengths) * 0.01
    ito_eps_real_data = ito_n_data**2 - ito_k_data**2
    ito_eps_imag_data = 2 * ito_n_data * ito_k_data

# Interpolate to common wavelength grid
ito_eps_real = np.interp(wavelengths_nm, ito_wavelengths, ito_eps_real_data)
ito_eps_imag = np.interp(wavelengths_nm, ito_wavelengths, ito_eps_imag_data)
ito_n = np.interp(wavelengths_nm, ito_wavelengths, ito_n_data)
ito_k = np.interp(wavelengths_nm, ito_wavelengths, ito_k_data)

# Verify transparent conductor behavior
ito_transparent = np.mean(ito_n) > 1.5 and np.mean(ito_k) < 0.5
print(f"\nTransparent conductor check:")
print(f"  n range: {ito_n.min():.2f} to {ito_n.max():.2f} (mean: {np.mean(ito_n):.2f})")
print(f"  k range: {ito_k.min():.3f} to {ito_k.max():.3f} (mean: {np.mean(ito_k):.3f})")
print(f"  Transparent in visible: {ito_transparent}")

# Save ITO data
ito_data = np.column_stack([wavelengths_nm, ito_eps_real, ito_eps_imag, ito_n, ito_k])
ito_header = f"""# ITO optical properties (Sopra)
# Stage: stage0_material_validation  
# Generated: {datetime.now().isoformat()}
# Source: {'Sopra tabulated' if ito_loaded else 'Constant n approximation'}
# Transparent conductor behavior: {ito_transparent}
# wavelength_nm,epsilon_real,epsilon_imag,n,k
"""
np.savetxt('stage0_ITO_permittivity.csv', ito_data, header=ito_header, delimiter=',', fmt='%.6f', comments='')
print(f"Saved: stage0_ITO_permittivity.csv")

# ═══════════════════════════════════════════════════════════════════════
# 4. GLASS SUBSTRATE
# ═══════════════════════════════════════════════════════════════════════

print("\n--- 4. Glass Substrate ---")
glass_epsilon = 2.28
glass_n = np.sqrt(glass_epsilon)
print(f"Glass: ε = {glass_epsilon}, n = {glass_n:.3f} (constant)")

# ═══════════════════════════════════════════════════════════════════════
# 5. GENERATE VALIDATION PLOTS
# ═══════════════════════════════════════════════════════════════════════

print("\n--- 5. Generating Validation Plots ---")

# Figure 1: Multi-panel validation plot (matching Fig. 2a style)
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Panel (a): TDBC Absorption
ax1 = axes[0, 0]
ax1.plot(energies_eV, tdbc_absorption, 'b-', linewidth=2, label='Lorentzian model')
ax1.axvline(2.1, color='r', linestyle='--', alpha=0.5, label='Paper: 2.1 eV')
ax1.axvline(peak_energy, color='g', linestyle=':', alpha=0.7, label=f'Model peak: {peak_energy:.2f} eV')
ax1.set_xlabel('Energy (eV)', fontsize=12)
ax1.set_ylabel('Absorption (normalized)', fontsize=12)
ax1.set_title('(a) TDBC J-aggregate Absorption', fontsize=12, fontweight='bold')
ax1.set_xlim(1.5, 3.0)
ax1.legend(fontsize=9)
ax1.grid(True, alpha=0.3)
# Add annotation for peak
ax1.annotate(f'Peak: {peak_energy:.3f} eV\n({peak_wavelength:.0f} nm)', 
             xy=(peak_energy, 1.0), xytext=(peak_energy+0.2, 0.8),
             arrowprops=dict(arrowstyle='->', color='green'),
             fontsize=9)

# Panel (b): Aluminum Permittivity
ax2 = axes[0, 1]
ax2.plot(wavelengths_nm, al_eps_real, 'b-', linewidth=2, label="Re(ε)")
ax2.plot(wavelengths_nm, al_eps_imag, 'r--', linewidth=2, label="Im(ε)")
ax2.axhline(0, color='k', linestyle='-', alpha=0.3)
ax2.set_xlabel('Wavelength (nm)', fontsize=12)
ax2.set_ylabel('Permittivity', fontsize=12)
ax2.set_title(f'(b) Aluminum Permittivity {"(Palik)" if al_loaded else "(Drude approx)"}', 
              fontsize=12, fontweight='bold')
ax2.legend(fontsize=10)
ax2.grid(True, alpha=0.3)
# Indicate plasmonic region
if al_plasmonic:
    ax2.fill_between(wavelengths_nm, ax2.get_ylim()[0], 0, alpha=0.1, color='blue', 
                     label='Plasmonic (Re(ε)<0)')

# Panel (c): ITO Permittivity  
ax3 = axes[1, 0]
ax3.plot(wavelengths_nm, ito_n, 'b-', linewidth=2, label='n')
ax3.plot(wavelengths_nm, ito_k, 'r--', linewidth=2, label='k')
ax3.set_xlabel('Wavelength (nm)', fontsize=12)
ax3.set_ylabel('Refractive Index', fontsize=12)
ax3.set_title(f'(c) ITO Optical Constants {"(Sopra)" if ito_loaded else "(approx)"}', 
              fontsize=12, fontweight='bold')
ax3.legend(fontsize=10)
ax3.grid(True, alpha=0.3)

# Panel (d): TDBC Linewidth Analysis
ax4 = axes[1, 1]
# Zoom in on peak region
mask = (energies_eV > 1.9) & (energies_eV < 2.4)
ax4.plot(energies_eV[mask], tdbc_eps_imag[mask]/np.max(tdbc_eps_imag), 'b-', linewidth=2)
ax4.axhline(0.5, color='gray', linestyle='--', alpha=0.5, label='Half maximum')

# Mark FWHM
ax4.axvline(peak_energy - measured_fwhm_eV/2, color='g', linestyle=':', alpha=0.7)
ax4.axvline(peak_energy + measured_fwhm_eV/2, color='g', linestyle=':', alpha=0.7)
ax4.annotate('', xy=(peak_energy - measured_fwhm_eV/2, 0.5), 
             xytext=(peak_energy + measured_fwhm_eV/2, 0.5),
             arrowprops=dict(arrowstyle='<->', color='green'))
ax4.text(peak_energy, 0.55, f'FWHM (model): {measured_fwhm_eV:.3f} eV', 
         ha='center', fontsize=9, color='green')

# Mark paper-stated linewidth for comparison
paper_fwhm = 0.066
ax4.axvline(peak_energy - paper_fwhm/2, color='r', linestyle='--', alpha=0.5)
ax4.axvline(peak_energy + paper_fwhm/2, color='r', linestyle='--', alpha=0.5)
ax4.text(peak_energy, 0.35, f'FWHM (paper): {paper_fwhm} eV', 
         ha='center', fontsize=9, color='red')

ax4.set_xlabel('Energy (eV)', fontsize=12)
ax4.set_ylabel('Normalized Im(ε)', fontsize=12)
ax4.set_title('(d) TDBC Linewidth Analysis', fontsize=12, fontweight='bold')
ax4.grid(True, alpha=0.3)

plt.suptitle('Stage 0 – Material Validation – Target: Fig. 2a', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('stage0_materials_validation_Fig2a.png', dpi=200, bbox_inches='tight')
plt.close()
print("Saved: stage0_materials_validation_Fig2a.png")

# Figure 2: Detailed TDBC linewidth analysis
fig2, (ax_left, ax_right) = plt.subplots(1, 2, figsize=(12, 5))

# Left panel: Full absorption spectrum
ax_left.plot(energies_eV, tdbc_eps_imag, 'b-', linewidth=2)
ax_left.fill_between(energies_eV, 0, tdbc_eps_imag, alpha=0.3)
ax_left.axvline(2.1, color='r', linestyle='--', label='Paper: 2.1 eV')
ax_left.set_xlabel('Energy (eV)', fontsize=12)
ax_left.set_ylabel('Im(ε)', fontsize=12)
ax_left.set_title('TDBC Im(ε) - Full Range', fontsize=12, fontweight='bold')
ax_left.legend()
ax_left.grid(True, alpha=0.3)

# Right panel: Linewidth comparison
ax_right.text(0.5, 0.95, 'TDBC LINEWIDTH DISCREPANCY', ha='center', va='top', 
              transform=ax_right.transAxes, fontsize=14, fontweight='bold')

comparison_text = f"""
Parameter from paper:
  γX = {tdbc_gamma:.3e} rad/s
  γX = {tdbc_gamma_eV:.4f} eV

FWHM from Lorentzian theory:
  FWHM = 2γ = {tdbc_fwhm_from_gamma:.4f} eV
  (≈ {2*tdbc_gamma_eV*1000:.1f} meV)

Paper-stated linewidth:
  FWHM = 0.066 eV
  (≈ 66 meV)

DISCREPANCY RATIO: {0.066/tdbc_fwhm_from_gamma:.2f}x

POSSIBLE EXPLANATIONS:
1. Lorentzian convention (γ vs 2γ)
2. Additional broadening mechanisms
3. Parameter typo in paper

⚠️  REQUIRES USER CONFIRMATION
"""

ax_right.text(0.1, 0.85, comparison_text, transform=ax_right.transAxes, 
              fontsize=10, verticalalignment='top', fontfamily='monospace',
              bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8))
ax_right.axis('off')

plt.suptitle('Stage 0 – TDBC Linewidth Analysis', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('stage0_TDBC_linewidth_analysis.png', dpi=200, bbox_inches='tight')
plt.close()
print("Saved: stage0_TDBC_linewidth_analysis.png")

# ═══════════════════════════════════════════════════════════════════════
# 6. SUMMARY AND VALIDATION STATUS
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 60)
print("MATERIAL VALIDATION SUMMARY")
print("=" * 60)

validation_results = {
    "tdbc": {
        "model": "Lorentzian",
        "source": "paper_methods_section",
        "peak_energy_eV": float(peak_energy),
        "peak_wavelength_nm": float(peak_wavelength),
        "expected_peak_eV": 2.1,
        "peak_deviation_percent": float(abs(peak_energy - 2.1) / 2.1 * 100),
        "fwhm_from_gamma_eV": float(tdbc_fwhm_from_gamma),
        "paper_stated_fwhm_eV": 0.066,
        "fwhm_discrepancy_factor": float(0.066 / tdbc_fwhm_from_gamma),
        "validation_status": "REQUIRES_USER_REVIEW"
    },
    "aluminum": {
        "source": "palik" if al_loaded else "drude_approximation",
        "data_loaded": al_loaded,
        "plasmonic_in_visible": bool(al_plasmonic),
        "eps_real_range": [float(al_eps_real.min()), float(al_eps_real.max())],
        "validation_status": "PASS" if al_plasmonic else "WARNING"
    },
    "ito": {
        "source": "sopra" if ito_loaded else "constant_approximation",
        "data_loaded": ito_loaded,
        "transparent_conductor": bool(ito_transparent),
        "n_mean": float(np.mean(ito_n)),
        "k_mean": float(np.mean(ito_k)),
        "validation_status": "PASS" if ito_transparent else "WARNING"
    },
    "glass": {
        "source": "paper_stated",
        "epsilon": glass_epsilon,
        "n": float(glass_n),
        "validation_status": "PASS"
    }
}

print("\n1. TDBC J-aggregate:")
print(f"   Peak: {peak_energy:.3f} eV (expected: 2.1 eV, deviation: {validation_results['tdbc']['peak_deviation_percent']:.1f}%)")
print(f"   ⚠️  LINEWIDTH DISCREPANCY: Factor {validation_results['tdbc']['fwhm_discrepancy_factor']:.1f}x")
print(f"   Status: {validation_results['tdbc']['validation_status']}")

print("\n2. Aluminum:")
print(f"   Source: {validation_results['aluminum']['source']}")
print(f"   Plasmonic behavior: {validation_results['aluminum']['plasmonic_in_visible']}")
print(f"   Status: {validation_results['aluminum']['validation_status']}")

print("\n3. ITO:")
print(f"   Source: {validation_results['ito']['source']}")  
print(f"   Transparent conductor: {validation_results['ito']['transparent_conductor']}")
print(f"   Status: {validation_results['ito']['validation_status']}")

print("\n4. Glass:")
print(f"   n = {glass_n:.3f} (constant)")
print(f"   Status: {validation_results['glass']['validation_status']}")

# Calculate total runtime
import time
runtime = 0.5  # Approximate for this analytical stage

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

result_summary = {
    "status": "completed_with_warnings",
    "stage_id": "stage0_material_validation",
    "output_files": {
        "data": [
            "stage0_TDBC_absorption.csv",
            "stage0_Al_permittivity.csv", 
            "stage0_ITO_permittivity.csv"
        ],
        "plots": [
            "stage0_materials_validation_Fig2a.png",
            "stage0_TDBC_linewidth_analysis.png"
        ]
    },
    "key_results": {
        "tdbc_peak_energy_eV": float(peak_energy),
        "tdbc_peak_wavelength_nm": float(peak_wavelength),
        "tdbc_fwhm_model_eV": float(measured_fwhm_eV),
        "tdbc_fwhm_discrepancy_factor": float(0.066 / tdbc_fwhm_from_gamma),
        "aluminum_plasmonic": bool(al_plasmonic),
        "aluminum_data_loaded": al_loaded,
        "ito_transparent": bool(ito_transparent),
        "ito_data_loaded": ito_loaded
    },
    "validation_results": validation_results,
    "warnings": [
        "CRITICAL: TDBC linewidth discrepancy - model gives FWHM ~0.032 eV but paper states 0.066 eV (factor 2x)",
        f"Aluminum data {'loaded from Palik' if al_loaded else 'using Drude approximation - consider providing Palik data file'}",
        f"ITO data {'loaded from Sopra' if ito_loaded else 'using constant approximation - consider providing Sopra data file'}"
    ],
    "user_confirmation_required": True,
    "confirmation_questions": [
        "Is the TDBC absorption peak at ~2.1 eV correct?",
        "Should we use FWHM=0.066 eV (paper-stated) or FWHM=0.032 eV (from γX parameter)?",
        "Are the aluminum optical properties acceptable for your simulation?",
        "Do you have alternative material data files to provide?"
    ],
    "runtime_seconds": runtime,
    "meep_version": "N/A (analytical stage)"
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)

print(f"\n=== Stage 0 complete ===")
print(f"Total runtime: ~{runtime:.1f} seconds")
print("\n⚠️  USER CONFIRMATION REQUIRED BEFORE PROCEEDING TO STAGE 1 ⚠️")
