#!/usr/bin/env python3
"""
Stage: stage1_bare_nanodisk
Target: Fig. 2b - Bare aluminum nanodisk LSP resonance validation
Description: 3D FDTD simulation of D=140nm, h=40nm aluminum nanodisk on ITO/glass
             to validate LSP resonance near 530nm with ~6× field enhancement.
Generated by: CodeGeneratorAgent
"""

import meep as mp
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from scipy.optimize import minimize
import json
import os

print("=" * 70)
print("STAGE 1: Bare Aluminum Nanodisk LSP Resonance Validation")
print("Target: Fig. 2b - Field enhancement |E/E0| ~ 6× at λ ~ 530nm")
print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("=" * 70)

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"] - MUST MATCH DESIGN)
# ═══════════════════════════════════════════════════════════════════════

a_unit = 1e-6  # 1 µm characteristic length (from design)
print(f"\nUnit system: a_unit = {a_unit} m (1 µm)")
print("All Meep coordinates are in units of 1 µm")

# ═══════════════════════════════════════════════════════════════════════
# SIMULATION PARAMETERS (from design specification)
# ═══════════════════════════════════════════════════════════════════════

# Cell dimensions (in µm = Meep units)
sx = 0.32  # Period in x (320 nm)
sy = 0.32  # Period in y (320 nm)
sz = 2.0   # Height (2 µm)

# Resolution
resolution = 100  # 100 pixels/µm = 10 nm grid spacing

# PML
pml_thickness = 0.5  # 500 nm PML

# Geometry parameters
disk_radius = 0.07      # 70 nm radius → D=140nm
disk_height = 0.04      # 40 nm height
ito_thickness = 0.03    # 30 nm ITO layer
substrate_thickness = 1.5  # Semi-infinite substrate into PML

# Positions (z-coordinates)
ito_center_z = 0.015    # ITO: z=0 to z=0.03
disk_center_z = 0.05    # Disk: z=0.03 to z=0.07 (on ITO)
substrate_center_z = -0.75  # Substrate extends into bottom PML

# Source parameters
fcen = 1.818   # Center frequency (550nm in Meep units: 1/0.55)
fwidth = 1.32  # Frequency width to cover 400-700nm
src_z = 0.35   # Source position (above structure)

# Monitor positions
trans_z = -0.40  # Transmission monitor (below substrate)
refl_z = 0.40    # Reflection monitor (above source)

# DFT field monitor frequency (at expected resonance ~530nm)
dft_freq = 1.0 / 0.530  # 1.887 in Meep units

# Number of frequency points for flux monitors
nfreq = 200

print(f"\nSimulation parameters:")
print(f"  Cell size: {sx} × {sy} × {sz} µm")
print(f"  Resolution: {resolution} pixels/µm ({1000/resolution:.1f} nm grid)")
print(f"  Total cells: {int(sx*resolution) * int(sy*resolution) * int(sz*resolution):,}")
print(f"  Disk: D={2*disk_radius*1000:.0f}nm, h={disk_height*1000:.0f}nm")
print(f"  Period: {sx*1000:.0f}nm (edge-to-edge: {(sx - 2*disk_radius)*1000:.0f}nm)")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL DEFINITIONS
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("MATERIAL DEFINITIONS")
print("=" * 70)

# --- Glass substrate (constant n=1.51, epsilon=2.28) ---
glass = mp.Medium(epsilon=2.28)
print(f"Glass: ε = 2.28 (n = 1.51)")

# --- ITO layer ---
# Load ITO permittivity data from stage0
ito_data_file = "stage0_ITO_permittivity.csv"
if os.path.exists(ito_data_file):
    print(f"Loading ITO data from {ito_data_file}...")
    ito_data = np.loadtxt(ito_data_file, delimiter=',', skiprows=1)
    ito_wl = ito_data[:, 0]  # wavelength in nm
    ito_n = ito_data[:, 1]   # refractive index n
    ito_k = ito_data[:, 2]   # extinction coefficient k
    
    # Use value at 550nm (center wavelength)
    idx_550 = np.argmin(np.abs(ito_wl - 550))
    ito_n_550 = ito_n[idx_550]
    ito_k_550 = ito_k[idx_550]
    ito_eps_real = ito_n_550**2 - ito_k_550**2
    ito_eps_imag = 2 * ito_n_550 * ito_k_550
    print(f"ITO at 550nm: n={ito_n_550:.3f}, k={ito_k_550:.4f}")
    print(f"ITO: ε' = {ito_eps_real:.3f}, ε'' = {ito_eps_imag:.4f}")
    # For simplicity, use real part only (ITO has low loss in visible)
    ITO = mp.Medium(epsilon=ito_eps_real)
else:
    print(f"WARNING: {ito_data_file} not found, using ε=3.8 approximation")
    ITO = mp.Medium(epsilon=3.8)

# --- Aluminum (Drude-Lorentz fit from Palik data) ---
al_data_file = "stage0_Al_permittivity.csv"
print(f"\nLoading aluminum data from {al_data_file}...")

if os.path.exists(al_data_file):
    al_data = np.loadtxt(al_data_file, delimiter=',', skiprows=1)
    al_wl_nm = al_data[:, 0]   # wavelength in nm
    al_n = al_data[:, 1]       # n
    al_k = al_data[:, 2]       # k
    
    # Convert to permittivity
    al_eps_real = al_n**2 - al_k**2
    al_eps_imag = 2 * al_n * al_k
    
    # Convert wavelength to Meep frequency
    al_freq_meep = 1.0 / (al_wl_nm * 1e-3)  # nm → µm → Meep freq
    
    print(f"  Wavelength range: {al_wl_nm.min():.0f} - {al_wl_nm.max():.0f} nm")
    print(f"  ε' range: {al_eps_real.min():.1f} to {al_eps_real.max():.1f}")
    print(f"  ε'' range: {al_eps_imag.min():.1f} to {al_eps_imag.max():.1f}")
    
    # Fit Drude-Lorentz model to the data
    # Model: ε(ω) = ε_inf - σ_d * ωp² / (ω² + i*γ_d*ω) + Σ σ_L * ω_L² / (ω_L² - ω² - i*γ_L*ω)
    
    def drude_lorentz_eps(freq, eps_inf, wp, gamma_d, w1, g1, s1, w2, g2, s2):
        """Calculate permittivity from Drude-Lorentz model."""
        omega = 2 * np.pi * freq
        # Drude term
        eps_drude = -wp**2 / (omega**2 + 1j * gamma_d * omega)
        # Lorentz terms
        eps_L1 = s1 * w1**2 / (w1**2 - omega**2 - 1j * g1 * omega)
        eps_L2 = s2 * w2**2 / (w2**2 - omega**2 - 1j * g2 * omega)
        return eps_inf + eps_drude + eps_L1 + eps_L2
    
    def objective(params):
        """Objective function for fitting."""
        eps_inf, wp, gamma_d, w1, g1, s1, w2, g2, s2 = params
        eps_model = drude_lorentz_eps(al_freq_meep, eps_inf, wp, gamma_d, w1, g1, s1, w2, g2, s2)
        eps_data = al_eps_real + 1j * al_eps_imag
        # Weight real part more heavily as it dominates
        error = np.sum(np.abs(eps_model.real - eps_data.real)**2) + \
                np.sum(np.abs(eps_model.imag - eps_data.imag)**2)
        return error
    
    # Initial guess based on design parameters (converted to angular frequency if needed)
    # Design uses Meep frequency units directly
    x0 = [1.0, 12.1, 0.081, 1.21, 0.48, 5.0, 2.42, 0.32, 1.5]
    
    # Bounds to keep parameters physical
    bounds = [(0.5, 2.0),     # eps_inf
              (8.0, 18.0),    # wp
              (0.01, 0.5),    # gamma_d
              (0.5, 3.0),     # w1
              (0.1, 1.5),     # g1
              (0.1, 15.0),    # s1
              (1.5, 4.0),     # w2
              (0.1, 1.5),     # g2
              (0.1, 5.0)]     # s2
    
    print("  Fitting Drude-Lorentz model to Palik data...")
    result = minimize(objective, x0, bounds=bounds, method='L-BFGS-B', 
                      options={'maxiter': 1000})
    
    if result.success:
        eps_inf, wp, gamma_d, w1, g1, s1, w2, g2, s2 = result.x
        print(f"  Fit converged! Final error: {result.fun:.2f}")
    else:
        print(f"  WARNING: Fit did not fully converge, using result anyway")
        eps_inf, wp, gamma_d, w1, g1, s1, w2, g2, s2 = result.x
    
    print(f"\n  Fitted Drude-Lorentz parameters:")
    print(f"    ε_inf = {eps_inf:.3f}")
    print(f"    Drude: ωp = {wp:.3f}, γ = {gamma_d:.4f}")
    print(f"    Lorentz 1: ω0 = {w1:.3f}, γ = {g1:.3f}, σ = {s1:.3f}")
    print(f"    Lorentz 2: ω0 = {w2:.3f}, γ = {g2:.3f}, σ = {s2:.3f}")
    
    # Verify fit quality at key wavelengths
    test_wls = [400, 500, 530, 600, 700]
    print(f"\n  Fit verification:")
    print(f"    λ(nm)   ε'(data)   ε'(fit)   ε''(data)  ε''(fit)")
    for wl in test_wls:
        idx = np.argmin(np.abs(al_wl_nm - wl))
        f_test = 1.0 / (wl * 1e-3)
        eps_fit = drude_lorentz_eps(f_test, eps_inf, wp, gamma_d, w1, g1, s1, w2, g2, s2)
        print(f"    {wl}     {al_eps_real[idx]:8.2f}   {eps_fit.real:8.2f}   {al_eps_imag[idx]:8.2f}   {eps_fit.imag:8.2f}")
    
    # Create Meep material with Drude + Lorentz susceptibilities
    # Note: Meep's DrudeSusceptibility uses σ=1 by convention
    # Meep formula: ε(ω) = ε_inf + σ * ωp² / (iγω - ω²)
    # Our formula: -ωp² / (ω² + iγω) = ωp² / (iγω - ω²) with σ=1
    
    aluminum = mp.Medium(
        epsilon=eps_inf,
        E_susceptibilities=[
            mp.DrudeSusceptibility(frequency=wp/(2*np.pi), gamma=gamma_d/(2*np.pi), sigma=1.0),
            mp.LorentzianSusceptibility(frequency=w1/(2*np.pi), gamma=g1/(2*np.pi), sigma=s1),
            mp.LorentzianSusceptibility(frequency=w2/(2*np.pi), gamma=g2/(2*np.pi), sigma=s2)
        ]
    )
    
else:
    print(f"WARNING: {al_data_file} not found!")
    print("Using default Drude-Lorentz parameters from design...")
    # Fallback to design parameters
    aluminum = mp.Medium(
        epsilon=1.0,
        E_susceptibilities=[
            mp.DrudeSusceptibility(frequency=12.1/(2*np.pi), gamma=0.081/(2*np.pi), sigma=1.0),
            mp.LorentzianSusceptibility(frequency=1.21/(2*np.pi), gamma=0.48/(2*np.pi), sigma=5.0),
            mp.LorentzianSusceptibility(frequency=2.42/(2*np.pi), gamma=0.32/(2*np.pi), sigma=1.5)
        ]
    )

# ═══════════════════════════════════════════════════════════════════════
# GEOMETRY CONSTRUCTION
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("GEOMETRY CONSTRUCTION")
print("=" * 70)

geometry = [
    # Glass substrate (extends into bottom PML)
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, substrate_thickness),
        center=mp.Vector3(0, 0, substrate_center_z),
        material=glass
    ),
    # ITO layer
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, ito_thickness),
        center=mp.Vector3(0, 0, ito_center_z),
        material=ITO
    ),
    # Aluminum nanodisk
    mp.Cylinder(
        radius=disk_radius,
        height=disk_height,
        center=mp.Vector3(0, 0, disk_center_z),
        axis=mp.Vector3(0, 0, 1),
        material=aluminum
    )
]

print(f"Glass substrate: center z={substrate_center_z} µm, thickness={substrate_thickness} µm")
print(f"ITO layer: center z={ito_center_z} µm, thickness={ito_thickness*1000:.0f} nm")
print(f"Al nanodisk: center z={disk_center_z} µm, D={2*disk_radius*1000:.0f} nm, h={disk_height*1000:.0f} nm")

# ═══════════════════════════════════════════════════════════════════════
# SIMULATION SETUP
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("SIMULATION SETUP")
print("=" * 70)

# Cell
cell = mp.Vector3(sx, sy, sz)

# Boundary layers (PML only in z, periodic in x and y)
pml_layers = [mp.PML(thickness=pml_thickness, direction=mp.Z)]

# Source: Ex-polarized plane wave
sources = [
    mp.Source(
        mp.GaussianSource(fcen, fwidth=fwidth),
        component=mp.Ex,
        center=mp.Vector3(0, 0, src_z),
        size=mp.Vector3(sx, sy, 0)
    )
]

# Symmetries: Ex is odd in x (phase=-1), even in y (phase=+1)
# This is CRITICAL for correct physics with Ex polarization
symmetries = [
    mp.Mirror(direction=mp.X, phase=-1),
    mp.Mirror(direction=mp.Y, phase=+1)
]

print(f"Source: Ex-polarized at z={src_z} µm")
print(f"  fcen={fcen:.3f} (λ_cen={1/fcen*1000:.0f}nm)")
print(f"  fwidth={fwidth:.3f} (λ range: {1/(fcen+fwidth/2)*1000:.0f}-{1/(fcen-fwidth/2)*1000:.0f}nm)")
print(f"Symmetries: X (phase=-1), Y (phase=+1) → 4× speedup")
print(f"PML: thickness={pml_thickness} µm in ±z directions")

# Flux monitor regions
trans_region = mp.FluxRegion(
    center=mp.Vector3(0, 0, trans_z),
    size=mp.Vector3(sx, sy, 0)
)
refl_region = mp.FluxRegion(
    center=mp.Vector3(0, 0, refl_z),
    size=mp.Vector3(sx, sy, 0),
    weight=-1  # For reflection calculation
)

print(f"Flux monitors: transmission at z={trans_z} µm, reflection at z={refl_z} µm")

# ═══════════════════════════════════════════════════════════════════════
# NORMALIZATION RUN (empty cell - no nanodisk)
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("NORMALIZATION RUN (substrate only, no nanodisk)")
print("=" * 70)

# Geometry without nanodisk (just substrate + ITO)
geometry_empty = [
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, substrate_thickness),
        center=mp.Vector3(0, 0, substrate_center_z),
        material=glass
    ),
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, ito_thickness),
        center=mp.Vector3(0, 0, ito_center_z),
        material=ITO
    )
]

sim_empty = mp.Simulation(
    cell_size=cell,
    geometry=geometry_empty,
    sources=sources,
    resolution=resolution,
    boundary_layers=pml_layers,
    symmetries=symmetries,
    k_point=mp.Vector3()  # Normal incidence (k=0)
)

# Add flux monitors
flux_trans_empty = sim_empty.add_flux(fcen, fwidth, nfreq, trans_region)
flux_refl_empty = sim_empty.add_flux(fcen, fwidth, nfreq, refl_region)

# Run until fields decay
decay_point = mp.Vector3(0, 0, trans_z)
print(f"Running normalization simulation...")
start_time = datetime.now()

sim_empty.run(
    until_after_sources=mp.stop_when_fields_decayed(50, mp.Ex, decay_point, 1e-5)
)

# Save flux data for normalization
empty_trans_data = sim_empty.get_flux_data(flux_trans_empty)
empty_refl_data = sim_empty.get_flux_data(flux_refl_empty)
empty_trans_flux = np.array(mp.get_fluxes(flux_trans_empty))
freqs = np.array(mp.get_flux_freqs(flux_trans_empty))

norm_time = (datetime.now() - start_time).total_seconds()
print(f"Normalization complete in {norm_time:.1f} seconds")
print(f"  Meep time: {sim_empty.meep_time():.1f}")

# ═══════════════════════════════════════════════════════════════════════
# MAIN SIMULATION RUN (with nanodisk)
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("MAIN SIMULATION RUN (with Al nanodisk)")
print("=" * 70)

sim = mp.Simulation(
    cell_size=cell,
    geometry=geometry,
    sources=sources,
    resolution=resolution,
    boundary_layers=pml_layers,
    symmetries=symmetries,
    k_point=mp.Vector3()
)

# Add flux monitors
flux_trans = sim.add_flux(fcen, fwidth, nfreq, trans_region)
flux_refl = sim.add_flux(fcen, fwidth, nfreq, refl_region)

# Load empty flux for reflection subtraction
sim.load_minus_flux_data(flux_refl, empty_refl_data)

# Add DFT field monitors
# XY plane at z=0.04 µm (10nm above ITO, at disk mid-height)
dft_xy = sim.add_dft_fields(
    [mp.Ex, mp.Ey, mp.Ez],
    [dft_freq],
    center=mp.Vector3(0, 0, 0.04),
    size=mp.Vector3(sx, sy, 0)
)

# XZ plane at y=0 (through disk center)
dft_xz = sim.add_dft_fields(
    [mp.Ex, mp.Ey, mp.Ez],
    [dft_freq],
    center=mp.Vector3(0, 0, 0.05),
    size=mp.Vector3(sx, 0, 0.3)
)

print(f"Running main simulation...")
print(f"DFT field monitor at λ={1/dft_freq*1000:.0f}nm (f={dft_freq:.3f})")
start_time = datetime.now()

sim.run(
    until_after_sources=mp.stop_when_fields_decayed(50, mp.Ex, decay_point, 1e-5)
)

main_time = (datetime.now() - start_time).total_seconds()
print(f"Main simulation complete in {main_time:.1f} seconds")
print(f"  Meep time: {sim.meep_time():.1f}")

# ═══════════════════════════════════════════════════════════════════════
# DATA EXTRACTION
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("DATA EXTRACTION")
print("=" * 70)

# Get flux values
struct_trans_flux = np.array(mp.get_fluxes(flux_trans))
struct_refl_flux = np.array(mp.get_fluxes(flux_refl))

# Calculate T, R, A
T = struct_trans_flux / empty_trans_flux
R = -struct_refl_flux / empty_trans_flux
A = 1 - T - R

# Ensure physical values (numerical noise can cause small negatives)
T = np.clip(T, 0, 1)
R = np.clip(R, 0, 1)
A = np.clip(A, 0, 1)

# Convert frequency to wavelength
wavelengths_nm = 1000.0 / freqs  # nm (since freqs are in 1/µm)

# Find resonance (absorption peak)
res_idx = np.argmax(A)
res_wl = wavelengths_nm[res_idx]
res_T = T[res_idx]
res_R = R[res_idx]
res_A = A[res_idx]

print(f"\nSpectral data computed:")
print(f"  Wavelength range: {wavelengths_nm.min():.0f} - {wavelengths_nm.max():.0f} nm")
print(f"  Number of frequency points: {len(freqs)}")
print(f"\nResonance detected:")
print(f"  λ_res = {res_wl:.1f} nm (expected: ~530 nm)")
print(f"  T = {res_T:.3f}, R = {res_R:.3f}, A = {res_A:.3f}")

# ═══════════════════════════════════════════════════════════════════════
# DFT FIELD EXTRACTION
# ═══════════════════════════════════════════════════════════════════════

print("\nExtracting DFT fields...")

# XY plane fields
Ex_xy = sim.get_dft_array(dft_xy, mp.Ex, 0)
Ey_xy = sim.get_dft_array(dft_xy, mp.Ey, 0)
Ez_xy = sim.get_dft_array(dft_xy, mp.Ez, 0)

# Total field magnitude
E_mag_xy = np.sqrt(np.abs(Ex_xy)**2 + np.abs(Ey_xy)**2 + np.abs(Ez_xy)**2)

# Incident field magnitude (for normalization)
# For plane wave source, |E0| ≈ 1 in normalized units, but we can estimate from max at edges
# More accurately, use the field value far from structure as reference
E0_estimate = np.mean(np.abs(Ex_xy[:3, :]))  # Edge values as reference
if E0_estimate < 0.01:
    E0_estimate = 1.0  # Default if edge values are too small
    print(f"  Using E0 = 1.0 (default)")
else:
    print(f"  Estimated E0 = {E0_estimate:.4f}")

E_enhancement_xy = E_mag_xy / E0_estimate

# XZ plane fields
Ex_xz = sim.get_dft_array(dft_xz, mp.Ex, 0)
Ey_xz = sim.get_dft_array(dft_xz, mp.Ey, 0)
Ez_xz = sim.get_dft_array(dft_xz, mp.Ez, 0)
E_mag_xz = np.sqrt(np.abs(Ex_xz)**2 + np.abs(Ey_xz)**2 + np.abs(Ez_xz)**2)
E_enhancement_xz = E_mag_xz / E0_estimate

max_enhancement = np.max(E_enhancement_xy)
print(f"\nField enhancement results:")
print(f"  Max |E/E0| in XY plane: {max_enhancement:.2f}× (expected: ~6×)")
print(f"  Max |E/E0| in XZ plane: {np.max(E_enhancement_xz):.2f}×")

# ═══════════════════════════════════════════════════════════════════════
# SAVE DATA FILES
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("SAVING OUTPUT FILES")
print("=" * 70)

# 1. Spectrum CSV
spectrum_file = "plexciton_stage1_fig2b_transmission.csv"
header = f"""# Stage: stage1_bare_nanodisk
# Target: Fig. 2b - Bare Al nanodisk LSP resonance
# Generated: {datetime.now().isoformat()}
# Disk: D={2*disk_radius*1000:.0f}nm, h={disk_height*1000:.0f}nm
# Period: {sx*1000:.0f}nm
# Resolution: {resolution} pixels/µm
# Resonance wavelength: {res_wl:.1f}nm
wavelength_nm,frequency_meep,transmission,reflection,absorption"""

spectrum_data = np.column_stack([wavelengths_nm, freqs, T, R, A])
np.savetxt(spectrum_file, spectrum_data, header=header, delimiter=',', fmt='%.6f', comments='')
print(f"Saved: {spectrum_file}")

# 2. Field data NPZ
field_file = "plexciton_stage1_fig2b_field.npz"
np.savez(field_file,
         # XY plane data
         Ex_xy=Ex_xy, Ey_xy=Ey_xy, Ez_xy=Ez_xy,
         E_mag_xy=E_mag_xy, E_enhancement_xy=E_enhancement_xy,
         # XZ plane data
         Ex_xz=Ex_xz, Ey_xz=Ey_xz, Ez_xz=Ez_xz,
         E_mag_xz=E_mag_xz, E_enhancement_xz=E_enhancement_xz,
         # Coordinates
         x_coords=np.linspace(-sx/2, sx/2, E_enhancement_xy.shape[0]),
         y_coords=np.linspace(-sy/2, sy/2, E_enhancement_xy.shape[1]),
         z_coords_xz=np.linspace(0.05-0.15, 0.05+0.15, E_enhancement_xz.shape[1]),
         # Metadata
         dft_wavelength_nm=1/dft_freq*1000,
         E0_estimate=E0_estimate,
         max_enhancement=max_enhancement,
         resonance_wavelength_nm=res_wl)
print(f"Saved: {field_file}")

# ═══════════════════════════════════════════════════════════════════════
# GENERATE PLOTS
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 70)
print("GENERATING PLOTS")
print("=" * 70)

# 1. Spectrum plot
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(wavelengths_nm, T, 'b-', linewidth=2, label='Transmission')
ax.plot(wavelengths_nm, R, 'r-', linewidth=2, label='Reflection')
ax.plot(wavelengths_nm, A, 'g-', linewidth=2, label='Absorption')
ax.axvline(x=530, color='gray', linestyle='--', alpha=0.5, label='Expected LSP (~530nm)')
ax.axvline(x=res_wl, color='k', linestyle=':', alpha=0.7, label=f'Simulated ({res_wl:.0f}nm)')
ax.set_xlabel('Wavelength (nm)', fontsize=12)
ax.set_ylabel('T / R / A', fontsize=12)
ax.set_xlim(400, 700)
ax.set_ylim(0, 1)
ax.legend(loc='best', fontsize=10)
ax.set_title(f'Stage 1 – Bare Al Nanodisk Spectrum – Target: Fig. 2b\n'
             f'D={2*disk_radius*1000:.0f}nm, h={disk_height*1000:.0f}nm, Period={sx*1000:.0f}nm',
             fontsize=11)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('plexciton_stage1_spectrum.png', dpi=200, bbox_inches='tight')
plt.close()
print("Saved: plexciton_stage1_spectrum.png")

# 2. Field enhancement map (XY plane)
fig, ax = plt.subplots(figsize=(8, 8))

x_coords = np.linspace(-sx/2*1000, sx/2*1000, E_enhancement_xy.shape[0])  # nm
y_coords = np.linspace(-sy/2*1000, sy/2*1000, E_enhancement_xy.shape[1])  # nm

# Clip enhancement for better visualization
vmax = min(max_enhancement, 10)
im = ax.imshow(E_enhancement_xy.T, origin='lower', cmap='hot',
               extent=[x_coords[0], x_coords[-1], y_coords[0], y_coords[-1]],
               vmin=0, vmax=vmax)

# Draw disk outline
disk_circle = plt.Circle((0, 0), disk_radius*1000, fill=False, 
                          color='white', linewidth=2, linestyle='--')
ax.add_patch(disk_circle)

cbar = plt.colorbar(im, ax=ax, label='|E/E₀|', shrink=0.8)
ax.set_xlabel('x (nm)', fontsize=12)
ax.set_ylabel('y (nm)', fontsize=12)
ax.set_title(f'Stage 1 – Field Enhancement |E/E₀| – Target: Fig. 2b\n'
             f'XY plane at z=40nm (10nm above ITO), λ={1/dft_freq*1000:.0f}nm\n'
             f'Max enhancement: {max_enhancement:.1f}× (expected: ~6×)',
             fontsize=11)
ax.set_aspect('equal')
plt.tight_layout()
plt.savefig('plexciton_stage1_fig2b_field_map.png', dpi=200, bbox_inches='tight')
plt.close()
print("Saved: plexciton_stage1_fig2b_field_map.png")

# 3. XZ cross-section field map
fig, ax = plt.subplots(figsize=(10, 6))

x_coords_xz = np.linspace(-sx/2*1000, sx/2*1000, E_enhancement_xz.shape[0])  # nm
z_coords_xz = np.linspace((0.05-0.15)*1000, (0.05+0.15)*1000, E_enhancement_xz.shape[1])  # nm

vmax_xz = min(np.max(E_enhancement_xz), 10)
im = ax.imshow(E_enhancement_xz.T, origin='lower', cmap='hot',
               extent=[x_coords_xz[0], x_coords_xz[-1], z_coords_xz[0], z_coords_xz[-1]],
               vmin=0, vmax=vmax_xz, aspect='auto')

# Draw structure outlines
# ITO layer
ax.axhline(y=0, color='cyan', linewidth=1, linestyle='-', alpha=0.7)
ax.axhline(y=30, color='cyan', linewidth=1, linestyle='-', alpha=0.7)
# Disk
disk_left = -disk_radius * 1000
disk_right = disk_radius * 1000
disk_bottom = 30  # nm
disk_top = 70  # nm
ax.plot([disk_left, disk_left, disk_right, disk_right, disk_left], 
        [disk_bottom, disk_top, disk_top, disk_bottom, disk_bottom], 
        'w--', linewidth=2)

cbar = plt.colorbar(im, ax=ax, label='|E/E₀|', shrink=0.8)
ax.set_xlabel('x (nm)', fontsize=12)
ax.set_ylabel('z (nm)', fontsize=12)
ax.set_title(f'Stage 1 – Field Enhancement |E/E₀| XZ Cross-section\n'
             f'y=0 plane, λ={1/dft_freq*1000:.0f}nm',
             fontsize=11)
plt.tight_layout()
plt.savefig('plexciton_stage1_field_xz.png', dpi=200, bbox_inches='tight')
plt.close()
print("Saved: plexciton_stage1_field_xz.png")

# ═══════════════════════════════════════════════════════════════════════
# FINAL SUMMARY
# ═══════════════════════════════════════════════════════════════════════

total_runtime = norm_time + main_time

print("\n" + "=" * 70)
print("SIMULATION SUMMARY")
print("=" * 70)
print(f"Total runtime: {total_runtime:.1f} seconds ({total_runtime/60:.1f} minutes)")
print(f"\nKey results:")
print(f"  Resonance wavelength: {res_wl:.1f} nm (expected: ~530 nm)")
print(f"  Max field enhancement: {max_enhancement:.1f}× (expected: ~6×)")
print(f"  Resonance absorption: {res_A:.2f}")
print(f"\nOutput files:")
print(f"  - plexciton_stage1_fig2b_transmission.csv")
print(f"  - plexciton_stage1_fig2b_field.npz")
print(f"  - plexciton_stage1_spectrum.png")
print(f"  - plexciton_stage1_fig2b_field_map.png")
print(f"  - plexciton_stage1_field_xz.png")

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

result_summary = {
    "status": "completed",
    "stage_id": "stage1_bare_nanodisk",
    "target_figure": "Fig. 2b",
    "output_files": {
        "data": ["plexciton_stage1_fig2b_transmission.csv", "plexciton_stage1_fig2b_field.npz"],
        "plots": ["plexciton_stage1_spectrum.png", "plexciton_stage1_fig2b_field_map.png", "plexciton_stage1_field_xz.png"]
    },
    "key_results": {
        "resonance_wavelength_nm": float(res_wl),
        "expected_resonance_nm": 530.0,
        "wavelength_error_percent": float(abs(res_wl - 530) / 530 * 100),
        "max_field_enhancement": float(max_enhancement),
        "expected_enhancement": 6.0,
        "resonance_transmission": float(res_T),
        "resonance_reflection": float(res_R),
        "resonance_absorption": float(res_A)
    },
    "simulation_parameters": {
        "disk_diameter_nm": float(2*disk_radius*1000),
        "disk_height_nm": float(disk_height*1000),
        "period_nm": float(sx*1000),
        "resolution_per_um": resolution
    },
    "runtime_seconds": float(total_runtime),
    "meep_version": mp.__version__ if hasattr(mp, '__version__') else "unknown"
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)
