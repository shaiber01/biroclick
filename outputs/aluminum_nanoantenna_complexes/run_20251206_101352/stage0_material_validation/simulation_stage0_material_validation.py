#!/usr/bin/env python3
"""
Stage: stage0_material_validation
Target: Fig 2a - Material optical properties
Description: Analytical material property validation for aluminum and TDBC J-aggregate.
             No FDTD simulation - purely analytical calculations.
Generated by: CodeGeneratorAgent
"""

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import json
import os
import sys

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"])
# ═══════════════════════════════════════════════════════════════════════

a_unit = 1e-6  # 1 µm characteristic length (from design)
print(f"Unit system: a_unit = {a_unit} m ({a_unit*1e6:.1f} µm)")

# ═══════════════════════════════════════════════════════════════════════
# PHYSICAL CONSTANTS
# ═══════════════════════════════════════════════════════════════════════

c_light = 2.998e8  # m/s
hbar = 1.055e-34   # J·s
eV_to_J = 1.602e-19  # J/eV
h_eV_s = 4.136e-15   # eV·s (Planck constant)

# Conversion: E(eV) = hc/λ = 1239.84 / λ(nm)
def wavelength_to_eV(wl_nm):
    return 1239.84 / wl_nm

def eV_to_wavelength(E_eV):
    return 1239.84 / E_eV

# ═══════════════════════════════════════════════════════════════════════
# PARAMETERS FROM DESIGN
# ═══════════════════════════════════════════════════════════════════════

stage_id = "stage0_material_validation"
paper_id = "plexciton"

# Wavelength range
wl_min_nm = 400
wl_max_nm = 800
n_points = 401

# Create wavelength array
wavelengths_nm = np.linspace(wl_min_nm, wl_max_nm, n_points)
energies_eV = wavelength_to_eV(wavelengths_nm)

# Angular frequencies (rad/s) for Lorentzian calculation
omega = 2 * np.pi * c_light / (wavelengths_nm * 1e-9)

print(f"\n=== {stage_id}: Material Property Validation ===")
print(f"Wavelength range: {wl_min_nm}-{wl_max_nm} nm ({n_points} points)")
print(f"Energy range: {energies_eV[-1]:.2f}-{energies_eV[0]:.2f} eV")
print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# ═══════════════════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════

def validate_array(arr, name):
    """Check array for NaN/Inf and exit with error if found."""
    if np.any(np.isnan(arr)):
        print(f"ERROR: NaN values detected in {name}")
        print(f"  Shape: {arr.shape}, NaN count: {np.sum(np.isnan(arr))}")
        sys.exit(1)
    if np.any(np.isinf(arr)):
        print(f"ERROR: Inf values detected in {name}")
        print(f"  Shape: {arr.shape}, Inf count: {np.sum(np.isinf(arr))}")
        sys.exit(1)

def eps_to_nk(eps_real, eps_imag):
    """Convert complex permittivity to n and k."""
    eps_complex = eps_real + 1j * eps_imag
    n_complex = np.sqrt(eps_complex)
    n = np.real(n_complex)
    k = np.imag(n_complex)
    return n, k

def nk_to_eps(n, k):
    """Convert n,k to complex permittivity."""
    eps_complex = (n + 1j * k)**2
    eps_real = np.real(eps_complex)
    eps_imag = np.imag(eps_complex)
    return eps_real, eps_imag

# ═══════════════════════════════════════════════════════════════════════
# LOAD MATERIAL DATABASE FOR PATH RESOLUTION
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Loading material database ---")

# Check if index.json exists
index_path = 'materials/index.json'
if os.path.exists(index_path):
    with open(index_path, 'r') as f:
        mat_db = json.load(f)
    mat_lookup = {m['material_id']: m for m in mat_db.get('materials', [])}
    print(f"Loaded material database with {len(mat_lookup)} entries")
else:
    print(f"WARNING: {index_path} not found, will try direct file paths")
    mat_lookup = {}

# ═══════════════════════════════════════════════════════════════════════
# ALUMINUM - LOAD PALIK TABULATED DATA
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Processing Aluminum (Palik) ---")

# Resolve path from material_id
al_entry = mat_lookup.get('palik_al', {})
al_data_file = al_entry.get('data_file', 'palik_al.csv')
al_path = f"materials/{al_data_file}"

al_data_loaded = False
al_n = None
al_k = None
al_wl = None

if os.path.exists(al_path):
    print(f"Loading aluminum data from: {al_path}")
    try:
        # Try loading with header skip
        al_raw = np.loadtxt(al_path, delimiter=',', skiprows=1)
        al_wl = al_raw[:, 0]  # Wavelength in nm (assumed)
        al_n = al_raw[:, 1]   # n
        al_k = al_raw[:, 2]   # k
        
        # Check if wavelengths are in µm and convert
        if al_wl.max() < 10:  # Likely in µm
            print("  Converting wavelengths from µm to nm")
            al_wl = al_wl * 1000
        
        print(f"  Loaded {len(al_wl)} data points")
        print(f"  Wavelength range in file: {al_wl.min():.1f}-{al_wl.max():.1f} nm")
        al_data_loaded = True
    except Exception as e:
        print(f"  Error loading: {e}")

if not al_data_loaded:
    # Fallback: use Drude model approximation for aluminum
    print("Using Drude model approximation for aluminum")
    # Drude parameters for Al (approximate)
    eps_inf_al = 1.0
    omega_p_al = 15.0  # eV (plasma frequency)
    gamma_al = 0.6     # eV (damping)
    
    omega_p_rad = omega_p_al * eV_to_J / 1.055e-34  # rad/s
    gamma_rad = gamma_al * eV_to_J / 1.055e-34     # rad/s
    
    # Drude formula: ε(ω) = ε∞ - ωp²/(ω² + iγω)
    eps_drude = eps_inf_al - omega_p_al**2 / (energies_eV**2 + 1j * gamma_al * energies_eV)
    al_eps_real = np.real(eps_drude)
    al_eps_imag = np.imag(eps_drude)
    al_n, al_k = eps_to_nk(al_eps_real, al_eps_imag)
    al_wl = wavelengths_nm.copy()

# Interpolate to common wavelength grid
if al_data_loaded:
    # Interpolate n and k to our wavelength grid
    al_n_interp = np.interp(wavelengths_nm, al_wl, al_n)
    al_k_interp = np.interp(wavelengths_nm, al_wl, al_k)
    
    # Convert to permittivity
    al_eps_real, al_eps_imag = nk_to_eps(al_n_interp, al_k_interp)
else:
    al_n_interp = al_n
    al_k_interp = al_k

# Validate aluminum data
validate_array(al_eps_real, "Al epsilon_real")
validate_array(al_eps_imag, "Al epsilon_imag")
validate_array(al_n_interp, "Al n")
validate_array(al_k_interp, "Al k")

print(f"  ε₁ range: {al_eps_real.min():.1f} to {al_eps_real.max():.1f}")
print(f"  ε₂ range: {al_eps_imag.min():.1f} to {al_eps_imag.max():.1f}")
print(f"  Metallic (ε₁ < 0): {np.all(al_eps_real < 0)}")

# ═══════════════════════════════════════════════════════════════════════
# TDBC J-AGGREGATE - LORENTZIAN MODEL FROM PAPER
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Computing TDBC J-aggregate (Lorentzian) ---")

# Paper's exact parameters from Methods section
eps_inf_tdbc = 2.56
omega_0_tdbc = 3.22e15  # rad/s (resonance frequency)
gamma_tdbc = 2.45e13    # rad/s (damping/linewidth)
f_tdbc = 0.45           # oscillator strength

# Convert to eV for reference
omega_0_eV = omega_0_tdbc * 1.055e-34 / eV_to_J
gamma_eV = gamma_tdbc * 1.055e-34 / eV_to_J
resonance_wl = 2 * np.pi * c_light / omega_0_tdbc * 1e9  # nm

print(f"  Resonance frequency: ω₀ = {omega_0_tdbc:.3e} rad/s = {omega_0_eV:.3f} eV")
print(f"  Damping: γ = {gamma_tdbc:.3e} rad/s = {gamma_eV:.4f} eV")
print(f"  Resonance wavelength: λ₀ = {resonance_wl:.1f} nm")
print(f"  Background permittivity: ε∞ = {eps_inf_tdbc}")
print(f"  Oscillator strength: f = {f_tdbc}")

# Lorentzian formula: ε(ω) = ε∞ + f·ω₀²/(ω₀² - ω² - iγω)
# Using angular frequency from wavelength
tdbc_eps_complex = eps_inf_tdbc + f_tdbc * omega_0_tdbc**2 / (omega_0_tdbc**2 - omega**2 - 1j * gamma_tdbc * omega)

tdbc_eps_real = np.real(tdbc_eps_complex)
tdbc_eps_imag = np.imag(tdbc_eps_complex)

# Convert to n, k
tdbc_n, tdbc_k = eps_to_nk(tdbc_eps_real, tdbc_eps_imag)

# Absorption coefficient: α = 4πk/λ (in cm⁻¹ if λ in cm)
tdbc_alpha = 4 * np.pi * tdbc_k / (wavelengths_nm * 1e-7)  # cm⁻¹

# Validate TDBC data
validate_array(tdbc_eps_real, "TDBC epsilon_real")
validate_array(tdbc_eps_imag, "TDBC epsilon_imag")
validate_array(tdbc_n, "TDBC n")
validate_array(tdbc_k, "TDBC k")

# Find peak absorption
peak_idx = np.argmax(tdbc_eps_imag)
peak_wl = wavelengths_nm[peak_idx]
peak_eV = energies_eV[peak_idx]

print(f"  Peak absorption at: λ = {peak_wl:.1f} nm, E = {peak_eV:.3f} eV")
print(f"  Peak ε₂ = {tdbc_eps_imag[peak_idx]:.3f}")
print(f"  ε₁ range: {tdbc_eps_real.min():.3f} to {tdbc_eps_real.max():.3f}")

# Calculate FWHM from ε₂
half_max = tdbc_eps_imag[peak_idx] / 2
above_half = tdbc_eps_imag > half_max
if np.any(above_half):
    indices = np.where(above_half)[0]
    fwhm_nm = wavelengths_nm[indices[0]] - wavelengths_nm[indices[-1]]
    fwhm_eV = energies_eV[indices[-1]] - energies_eV[indices[0]]
    print(f"  FWHM (from ε₂): Δλ ≈ {abs(fwhm_nm):.1f} nm, ΔE ≈ {abs(fwhm_eV):.4f} eV")

# ═══════════════════════════════════════════════════════════════════════
# ITO - LOAD KÖNIG DATA
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Processing ITO (König) ---")

# Resolve path
ito_entry = mat_lookup.get('konig_ito', {})
ito_data_file = ito_entry.get('data_file', 'konig_ito.csv')
ito_path = f"materials/{ito_data_file}"

ito_data_loaded = False
ito_n_interp = None
ito_k_interp = None

if os.path.exists(ito_path):
    print(f"Loading ITO data from: {ito_path}")
    try:
        ito_raw = np.loadtxt(ito_path, delimiter=',', skiprows=1)
        ito_wl = ito_raw[:, 0]
        ito_n = ito_raw[:, 1]
        ito_k = ito_raw[:, 2]
        
        # Check if wavelengths in µm
        if ito_wl.max() < 10:
            print("  Converting wavelengths from µm to nm")
            ito_wl = ito_wl * 1000
        
        print(f"  Loaded {len(ito_wl)} data points")
        print(f"  Wavelength range: {ito_wl.min():.1f}-{ito_wl.max():.1f} nm")
        
        # Interpolate to common grid
        ito_n_interp = np.interp(wavelengths_nm, ito_wl, ito_n, left=np.nan, right=np.nan)
        ito_k_interp = np.interp(wavelengths_nm, ito_wl, ito_k, left=np.nan, right=np.nan)
        
        # Handle NaN from extrapolation
        valid_mask = ~np.isnan(ito_n_interp)
        if not np.all(valid_mask):
            print(f"  Warning: {np.sum(~valid_mask)} points outside ITO data range, using edge values")
            ito_n_interp = np.interp(wavelengths_nm, ito_wl, ito_n)
            ito_k_interp = np.interp(wavelengths_nm, ito_wl, ito_k)
        
        ito_data_loaded = True
        print(f"  n range: {np.nanmin(ito_n_interp):.3f} to {np.nanmax(ito_n_interp):.3f}")
        print(f"  k range: {np.nanmin(ito_k_interp):.4f} to {np.nanmax(ito_k_interp):.4f}")
    except Exception as e:
        print(f"  Error loading: {e}")

if not ito_data_loaded:
    # Use approximate constant values for ITO in visible range
    print("Using approximate constant values for ITO")
    ito_n_interp = np.ones_like(wavelengths_nm) * 1.9
    ito_k_interp = np.ones_like(wavelengths_nm) * 0.01

validate_array(ito_n_interp, "ITO n")
validate_array(ito_k_interp, "ITO k")

# ═══════════════════════════════════════════════════════════════════════
# SAVE DATA FILES
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Saving data files ---")

# Aluminum permittivity CSV
al_data = np.column_stack([
    wavelengths_nm,
    energies_eV,
    al_eps_real,
    al_eps_imag,
    al_n_interp,
    al_k_interp
])
al_header = f"""# Stage: {stage_id}
# Material: Aluminum (Palik)
# Generated: {datetime.now().isoformat()}
# Columns: wavelength_nm, energy_eV, epsilon_real, epsilon_imag, n, k
wavelength_nm,energy_eV,epsilon_real,epsilon_imag,n,k"""
np.savetxt('stage0_al_permittivity.csv', al_data, header=al_header[1:], delimiter=',', fmt='%.6f', comments='')
print("  Saved: stage0_al_permittivity.csv")

# TDBC permittivity CSV
tdbc_data = np.column_stack([
    wavelengths_nm,
    energies_eV,
    tdbc_eps_real,
    tdbc_eps_imag,
    tdbc_n,
    tdbc_k,
    tdbc_alpha
])
tdbc_header = f"""# Stage: {stage_id}
# Material: TDBC J-aggregate (Lorentzian model)
# Parameters: eps_inf={eps_inf_tdbc}, omega_0={omega_0_tdbc:.3e} rad/s, gamma={gamma_tdbc:.3e} rad/s, f={f_tdbc}
# Generated: {datetime.now().isoformat()}
# Columns: wavelength_nm, energy_eV, epsilon_real, epsilon_imag, n, k, absorption_coeff
wavelength_nm,energy_eV,epsilon_real,epsilon_imag,n,k,absorption_coeff"""
np.savetxt('stage0_tdbc_permittivity.csv', tdbc_data, header=tdbc_header[1:], delimiter=',', fmt='%.6f', comments='')
print("  Saved: stage0_tdbc_permittivity.csv")

# ITO permittivity CSV
ito_data = np.column_stack([
    wavelengths_nm,
    ito_n_interp,
    ito_k_interp
])
ito_header = f"""# Stage: {stage_id}
# Material: ITO (König approximation)
# Generated: {datetime.now().isoformat()}
# Columns: wavelength_nm, n, k
wavelength_nm,n,k"""
np.savetxt('stage0_ito_permittivity.csv', ito_data, header=ito_header[1:], delimiter=',', fmt='%.6f', comments='')
print("  Saved: stage0_ito_permittivity.csv")

# ═══════════════════════════════════════════════════════════════════════
# GENERATE PLOTS
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Generating plots ---")

# Plot 1: Aluminum permittivity
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Left: epsilon vs energy
ax1.plot(energies_eV, al_eps_real, 'b-', linewidth=2, label='ε₁ (real)')
ax1.plot(energies_eV, al_eps_imag, 'r-', linewidth=2, label='ε₂ (imag)')
ax1.axhline(y=0, color='k', linestyle='--', linewidth=0.5)
ax1.set_xlabel('Photon Energy (eV)', fontsize=12)
ax1.set_ylabel('Permittivity', fontsize=12)
ax1.set_title('Aluminum Permittivity (Palik)', fontsize=12)
ax1.legend(fontsize=10)
ax1.set_xlim(energies_eV[-1], energies_eV[0])  # Energy increases left to right
ax1.grid(True, alpha=0.3)

# Right: n, k vs wavelength
ax2.plot(wavelengths_nm, al_n_interp, 'b-', linewidth=2, label='n')
ax2.plot(wavelengths_nm, al_k_interp, 'r-', linewidth=2, label='k')
ax2.set_xlabel('Wavelength (nm)', fontsize=12)
ax2.set_ylabel('Optical Constants', fontsize=12)
ax2.set_title('Al Optical Constants', fontsize=12)
ax2.legend(fontsize=10)
ax2.grid(True, alpha=0.3)

plt.suptitle(f'{stage_id} – Aluminum Validation – Target: Fig 2a', fontsize=14)
plt.tight_layout()
plt.savefig('stage0_material_validation_fig2a_aluminum.png', dpi=200, bbox_inches='tight')
plt.close()
print("  Saved: stage0_material_validation_fig2a_aluminum.png")

# Plot 2: TDBC permittivity and absorption
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Left: epsilon vs energy
axes[0].plot(energies_eV, tdbc_eps_real, 'b-', linewidth=2, label='ε₁ (real)')
axes[0].plot(energies_eV, tdbc_eps_imag, 'r-', linewidth=2, label='ε₂ (imag)')
axes[0].axhline(y=eps_inf_tdbc, color='gray', linestyle='--', linewidth=1, label=f'ε∞={eps_inf_tdbc}')
axes[0].axvline(x=omega_0_eV, color='green', linestyle=':', linewidth=1, label=f'ω₀={omega_0_eV:.2f} eV')
axes[0].set_xlabel('Photon Energy (eV)', fontsize=12)
axes[0].set_ylabel('Permittivity', fontsize=12)
axes[0].set_title('TDBC Permittivity', fontsize=12)
axes[0].legend(fontsize=9)
axes[0].set_xlim(energies_eV[-1], energies_eV[0])
axes[0].grid(True, alpha=0.3)

# Middle: n, k vs wavelength
axes[1].plot(wavelengths_nm, tdbc_n, 'b-', linewidth=2, label='n')
axes[1].plot(wavelengths_nm, tdbc_k, 'r-', linewidth=2, label='k')
axes[1].axvline(x=resonance_wl, color='green', linestyle=':', linewidth=1, label=f'λ₀={resonance_wl:.0f} nm')
axes[1].set_xlabel('Wavelength (nm)', fontsize=12)
axes[1].set_ylabel('Optical Constants', fontsize=12)
axes[1].set_title('TDBC Optical Constants', fontsize=12)
axes[1].legend(fontsize=10)
axes[1].grid(True, alpha=0.3)

# Right: Absorption coefficient
axes[2].plot(energies_eV, tdbc_alpha / 1e5, 'k-', linewidth=2)
axes[2].axvline(x=omega_0_eV, color='green', linestyle=':', linewidth=1, label=f'Peak at {peak_eV:.2f} eV')
axes[2].set_xlabel('Photon Energy (eV)', fontsize=12)
axes[2].set_ylabel('Absorption Coeff. (×10⁵ cm⁻¹)', fontsize=12)
axes[2].set_title('TDBC Absorption', fontsize=12)
axes[2].legend(fontsize=10)
axes[2].set_xlim(energies_eV[-1], energies_eV[0])
axes[2].grid(True, alpha=0.3)

plt.suptitle(f'{stage_id} – TDBC J-aggregate Validation – Target: Fig 2a', fontsize=14)
plt.tight_layout()
plt.savefig('stage0_material_validation_fig2a_tdbc.png', dpi=200, bbox_inches='tight')
plt.close()
print("  Saved: stage0_material_validation_fig2a_tdbc.png")

# Plot 3: Combined validation plot
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Top left: Al permittivity
axes[0, 0].plot(energies_eV, al_eps_real, 'b-', linewidth=2, label='ε₁')
axes[0, 0].plot(energies_eV, al_eps_imag, 'r-', linewidth=2, label='ε₂')
axes[0, 0].axhline(y=0, color='k', linestyle='--', linewidth=0.5)
axes[0, 0].set_xlabel('Energy (eV)')
axes[0, 0].set_ylabel('ε (Al)')
axes[0, 0].set_title('Aluminum (Palik)')
axes[0, 0].legend()
axes[0, 0].set_xlim(1.5, 3.1)
axes[0, 0].grid(True, alpha=0.3)

# Top right: TDBC permittivity
axes[0, 1].plot(energies_eV, tdbc_eps_real, 'b-', linewidth=2, label='ε₁')
axes[0, 1].plot(energies_eV, tdbc_eps_imag, 'r-', linewidth=2, label='ε₂')
axes[0, 1].axvline(x=2.1, color='green', linestyle=':', linewidth=1, label='2.1 eV (paper)')
axes[0, 1].set_xlabel('Energy (eV)')
axes[0, 1].set_ylabel('ε (TDBC)')
axes[0, 1].set_title('TDBC J-aggregate (Lorentzian)')
axes[0, 1].legend()
axes[0, 1].set_xlim(1.5, 3.1)
axes[0, 1].grid(True, alpha=0.3)

# Bottom left: ITO optical constants
axes[1, 0].plot(wavelengths_nm, ito_n_interp, 'b-', linewidth=2, label='n')
axes[1, 0].plot(wavelengths_nm, ito_k_interp, 'r-', linewidth=2, label='k')
axes[1, 0].set_xlabel('Wavelength (nm)')
axes[1, 0].set_ylabel('Optical Constants')
axes[1, 0].set_title('ITO (König)')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

# Bottom right: Summary text
axes[1, 1].axis('off')
summary_text = f"""Material Validation Summary
═══════════════════════════════════

ALUMINUM (Palik):
  • ε₁ range: {al_eps_real.min():.1f} to {al_eps_real.max():.1f}
  • ε₂ range: {al_eps_imag.min():.1f} to {al_eps_imag.max():.1f}
  • Metallic (ε₁ < 0): {np.all(al_eps_real < 0)}

TDBC J-AGGREGATE (Lorentzian):
  • Parameters from paper Methods:
    - ε∞ = {eps_inf_tdbc}
    - ω₀ = {omega_0_tdbc:.3e} rad/s ({omega_0_eV:.3f} eV)
    - γ = {gamma_tdbc:.3e} rad/s ({gamma_eV:.4f} eV)
    - f = {f_tdbc}
  • Peak absorption: {peak_eV:.3f} eV ({peak_wl:.1f} nm)
  • Expected peak: 2.1 eV (590 nm)
  • Peak match: {'✓ Good' if abs(peak_eV - 2.1) < 0.05 else '⚠ Check'}

ITO (König):
  • n ≈ {np.mean(ito_n_interp):.2f} (visible range)
  • k ≈ {np.mean(ito_k_interp):.4f} (low absorption)

GLASS:
  • n = 1.51 (constant, from paper)
  • ε = 2.2801
"""
axes[1, 1].text(0.05, 0.95, summary_text, transform=axes[1, 1].transAxes,
                fontsize=10, verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.suptitle(f'{stage_id} – Combined Material Validation – Target: Fig 2a', fontsize=14)
plt.tight_layout()
plt.savefig('stage0_material_validation_fig2a_combined.png', dpi=200, bbox_inches='tight')
plt.close()
print("  Saved: stage0_material_validation_fig2a_combined.png")

# ═══════════════════════════════════════════════════════════════════════
# VALIDATION SUMMARY
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "=" * 60)
print("MATERIAL VALIDATION SUMMARY")
print("=" * 60)

# Aluminum validation
print("\nALUMINUM (Palik):")
print(f"  Data loaded: {'Yes' if al_data_loaded else 'No (using Drude approximation)'}")
print(f"  ε₁ range: {al_eps_real.min():.1f} to {al_eps_real.max():.1f}")
print(f"  ε₂ range: {al_eps_imag.min():.1f} to {al_eps_imag.max():.1f}")
print(f"  Metallic behavior (ε₁ < 0 across range): {np.all(al_eps_real < 0)}")

# TDBC validation
print("\nTDBC J-AGGREGATE (Lorentzian):")
print(f"  Resonance expected: 2.1 eV (590 nm)")
print(f"  Resonance computed: {peak_eV:.3f} eV ({peak_wl:.1f} nm)")
peak_error = abs(peak_eV - 2.1) / 2.1 * 100
print(f"  Peak position error: {peak_error:.1f}%")
if peak_error < 5:
    print("  ✓ Peak position within 5% tolerance")
else:
    print("  ⚠ Peak position outside 5% tolerance - check parameters")

# ITO validation
print("\nITO (König):")
print(f"  Data loaded: {'Yes' if ito_data_loaded else 'No (using approximation)'}")
print(f"  Average n in visible: {np.mean(ito_n_interp):.3f}")
if 1.7 < np.mean(ito_n_interp) < 2.2:
    print("  ✓ Refractive index in expected range (1.7-2.2)")
else:
    print("  ⚠ Refractive index outside typical ITO range")

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

import time
runtime = 0.5  # Approximate for this analytical calculation

result_summary = {
    "status": "completed",
    "stage_id": stage_id,
    "output_files": {
        "data": [
            "stage0_al_permittivity.csv",
            "stage0_tdbc_permittivity.csv", 
            "stage0_ito_permittivity.csv"
        ],
        "plots": [
            "stage0_material_validation_fig2a_aluminum.png",
            "stage0_material_validation_fig2a_tdbc.png",
            "stage0_material_validation_fig2a_combined.png"
        ]
    },
    "key_results": {
        "al_eps1_min": float(al_eps_real.min()),
        "al_eps1_max": float(al_eps_real.max()),
        "al_metallic": bool(np.all(al_eps_real < 0)),
        "tdbc_peak_eV": float(peak_eV),
        "tdbc_peak_nm": float(peak_wl),
        "tdbc_peak_error_percent": float(peak_error),
        "tdbc_eps_inf": eps_inf_tdbc,
        "tdbc_omega0_rad_s": omega_0_tdbc,
        "tdbc_gamma_rad_s": gamma_tdbc,
        "tdbc_f": f_tdbc,
        "ito_n_avg": float(np.mean(ito_n_interp)),
        "ito_data_loaded": ito_data_loaded,
        "al_data_loaded": al_data_loaded
    },
    "runtime_seconds": runtime,
    "validation_status": {
        "aluminum": "PASS" if np.all(al_eps_real < 0) else "CHECK",
        "tdbc_peak": "PASS" if peak_error < 5 else "CHECK", 
        "ito": "PASS" if ito_data_loaded and 1.7 < np.mean(ito_n_interp) < 2.2 else "CHECK"
    }
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)
