#!/usr/bin/env python3
"""
Stage: stage1_bare_disk_single
Target: Fig_bare_disk_spectra (transmission spectrum of bare Al nanodisk array)
Description: 3D FDTD simulation of Al nanodisk (D=140nm, h=40nm) on ITO(30nm)/glass 
             with periodic BCs (period=320nm). Measures transmission spectrum to 
             validate bare plasmonic response before TDBC coupling.
Generated by: CodeGeneratorAgent
Revision: Fixed reflection flux sign convention (R = -flux/flux_ref per Meep convention)
"""

import meep as mp
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from scipy.optimize import minimize
import json
import sys
import os

start_time = datetime.now()
print(f"=== stage1_bare_disk_single: Bare Al Nanodisk Transmission ===")
print(f"Target figures: Fig_bare_disk_spectra")
print(f"Started at: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"] - MUST MATCH DESIGN)
# ═══════════════════════════════════════════════════════════════════════

a_unit = 1e-6  # 1 µm characteristic length (from design)
print(f"\nUnit system: a_unit = {a_unit} m (1 µm)")
print("All Meep coordinates are in units of 1 µm")

# ═══════════════════════════════════════════════════════════════════════
# SIMULATION PARAMETERS (from design specification)
# ═══════════════════════════════════════════════════════════════════════

# Cell size (in Meep units = µm)
sx = 0.32  # period in x (320 nm)
sy = 0.32  # period in y (320 nm)
sz = 3.0   # z extent

# Resolution
resolution = 100  # 100 pixels/µm = 10 nm grid

# PML
pml_thickness = 0.5  # 500 nm

# Geometry parameters
disk_radius = 0.07      # 70 nm radius (D=140nm)
disk_height = 0.04      # 40 nm height
disk_center_z = 0.05    # center z position

ito_thickness = 0.03    # 30 nm
ito_center_z = 0.015    # center of ITO layer

glass_thickness = 1.5   # modeled portion of semi-infinite substrate
glass_center_z = -0.75

# Source parameters (from design)
fcen = 1.818      # center frequency (550 nm)
fwidth = 1.2      # frequency width to cover 400-700 nm
src_z = 0.7       # source position - safely inside simulation domain

# Monitor positions
trans_z = -0.8    # transmission monitor (in glass, above bottom PML at z=-1.0)
refl_z = 0.5      # reflection monitor between source (z=0.7) and structure (z~0.05)

# Frequency points for flux monitors
nfreq = 200

# Decay threshold
decay_by = 1e-5

print(f"\nGeometry parameters:")
print(f"  Cell size: {sx}×{sy}×{sz} µm ({sx*1e3:.0f}×{sy*1e3:.0f}×{sz*1e3:.0f} nm)")
print(f"  Resolution: {resolution} pts/µm ({1000/resolution:.0f} nm grid)")
print(f"  Total cells: {int(sx*resolution)*int(sy*resolution)*int(sz*resolution):,}")
print(f"  Disk: D={2*disk_radius*1e3:.0f} nm, h={disk_height*1e3:.0f} nm")
print(f"  ITO: {ito_thickness*1e3:.0f} nm")
print(f"  Period: {sx*1e3:.0f} nm (gap Γ={(sx-2*disk_radius)*1e3:.0f} nm)")
print(f"  Source z={src_z}")
print(f"  Reflection monitor z={refl_z} (between source and structure)")
print(f"  Transmission monitor z={trans_z}")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL DEFINITIONS
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Loading and fitting material data ---")

# Glass (non-dispersive)
n_glass = 1.51
glass = mp.Medium(epsilon=n_glass**2)
print(f"Glass: n={n_glass}, ε={n_glass**2:.4f}")

# Function to fit Drude-Lorentz model to permittivity data
def fit_drude_lorentz(wavelengths_nm, eps_real, eps_imag, n_poles=4, material_name="material"):
    """
    Fit Drude-Lorentz model to complex permittivity data.
    Returns Meep-compatible susceptibility parameters.
    """
    # Convert to Meep frequency units (c=1, a=1µm)
    freqs_meep = 1.0 / (wavelengths_nm * 1e-3)  # f = c/λ, λ in µm
    omega_meep = 2 * np.pi * freqs_meep
    
    eps_data = eps_real + 1j * eps_imag
    
    n_lorentz = n_poles - 1
    
    def model_eps(params, omega):
        eps_inf = params[0]
        omega_p = params[1]
        gamma_d = params[2]
        
        # Drude contribution
        eps = eps_inf - omega_p**2 / (omega**2 + 1j * omega * gamma_d)
        
        # Lorentz contributions
        for i in range(n_lorentz):
            idx = 3 + 3*i
            omega_j = params[idx]
            gamma_j = params[idx + 1]
            sigma_j = params[idx + 2]
            eps += sigma_j * omega_j**2 / (omega_j**2 - omega**2 - 1j * omega * gamma_j)
        
        return eps
    
    def objective(params):
        eps_model = model_eps(params, omega_meep)
        weights = np.ones_like(freqs_meep)
        err = np.abs(eps_model - eps_data)**2 * weights
        return np.sum(err)
    
    p0 = [1.0, 15.0, 0.5]
    freq_range = np.linspace(freqs_meep.min(), freqs_meep.max(), n_lorentz + 2)[1:-1]
    for f in freq_range:
        omega_j = 2 * np.pi * f
        p0.extend([omega_j, 1.0, 1.0])
    
    bounds = [(0.1, 10), (1, 50), (0.01, 5)]
    for _ in range(n_lorentz):
        bounds.extend([(0.1, 100), (0.01, 10), (-50, 50)])
    
    result = minimize(objective, p0, method='L-BFGS-B', bounds=bounds, 
                     options={'maxiter': 1000})
    
    params_opt = result.x
    eps_fit = model_eps(params_opt, omega_meep)
    
    rms_error = np.sqrt(np.mean(np.abs(eps_fit - eps_data)**2))
    max_error = np.max(np.abs(eps_fit - eps_data))
    
    print(f"  {material_name} fit: RMS error={rms_error:.3f}, max error={max_error:.3f}")
    
    return params_opt, eps_fit, rms_error

def create_meep_medium(params, n_lorentz):
    """Convert fitted parameters to Meep Medium object."""
    eps_inf = params[0]
    omega_p = params[1]
    gamma_d = params[2]
    
    susceptibilities = []
    
    drude_freq = omega_p / (2 * np.pi)
    drude_gamma = gamma_d / (2 * np.pi)
    
    susceptibilities.append(
        mp.DrudeSusceptibility(frequency=drude_freq, gamma=drude_gamma, sigma=1.0)
    )
    
    for i in range(n_lorentz):
        idx = 3 + 3*i
        omega_j = params[idx]
        gamma_j = params[idx + 1]
        sigma_j = params[idx + 2]
        
        lorentz_freq = omega_j / (2 * np.pi)
        lorentz_gamma = gamma_j / (2 * np.pi)
        
        susceptibilities.append(
            mp.LorentzianSusceptibility(frequency=lorentz_freq, gamma=lorentz_gamma, sigma=sigma_j)
        )
    
    return mp.Medium(epsilon=eps_inf, E_susceptibilities=susceptibilities)

# IMPROVED: Robust fallback Drude-Lorentz parameters for Aluminum
# Based on Rakic et al. 1998 - validated parameters for visible range
def create_aluminum_fallback():
    """
    Create aluminum medium using Rakic 1998 Drude-Lorentz parameters.
    These are well-validated for the 400-700 nm (1.77-3.1 eV) range.
    """
    print("  Using Rakic 1998 Drude-Lorentz model for Aluminum")
    
    # Convert eV to Meep frequency: f_meep = E_eV / 1.23984 (since a=1µm, c=1)
    eV_to_meep_freq = 1.0 / 1.23984
    
    # Rakic 1998 parameters for Al (Drude + 4 Lorentz oscillators)
    # Drude: ω_p = 14.98 eV, γ = 0.047 eV
    # We use a simplified 1 Drude + 2 Lorentz model for visible range
    
    al_eps_inf = 1.0
    al_omega_p = 14.98 * eV_to_meep_freq  # plasma frequency
    al_gamma_d = 0.047 * eV_to_meep_freq   # Drude damping
    
    # Lorentz oscillators for interband transitions
    # First interband: ~1.5 eV
    l1_omega = 1.5 * eV_to_meep_freq
    l1_gamma = 0.3 * eV_to_meep_freq
    l1_sigma = 0.5
    
    # Second interband: ~2.5 eV  
    l2_omega = 2.5 * eV_to_meep_freq
    l2_gamma = 0.5 * eV_to_meep_freq
    l2_sigma = 0.2
    
    susceptibilities = [
        mp.DrudeSusceptibility(frequency=al_omega_p, gamma=al_gamma_d, sigma=1.0),
        mp.LorentzianSusceptibility(frequency=l1_omega, gamma=l1_gamma, sigma=l1_sigma),
        mp.LorentzianSusceptibility(frequency=l2_omega, gamma=l2_gamma, sigma=l2_sigma)
    ]
    
    print(f"    Drude: ω_p={al_omega_p:.3f}, γ={al_gamma_d:.4f}")
    print(f"    Lorentz 1: ω={l1_omega:.3f}, γ={l1_gamma:.3f}, σ={l1_sigma}")
    print(f"    Lorentz 2: ω={l2_omega:.3f}, γ={l2_gamma:.3f}, σ={l2_sigma}")
    
    return mp.Medium(epsilon=al_eps_inf, E_susceptibilities=susceptibilities)

def create_ito_fallback():
    """
    Create ITO medium using literature values.
    ITO in visible range: n ~ 1.9-2.0, low absorption.
    Using König/Sopra-like parameters.
    """
    print("  Using literature-based model for ITO")
    
    # ITO is weakly dispersive in visible, with n ~ 1.9-2.0
    # Small Drude contribution from free carriers + Lorentz for bandgap
    eV_to_meep_freq = 1.0 / 1.23984
    
    ito_eps_inf = 3.5  # ~n=1.87 background
    
    # Weak Drude from free carriers (low carrier concentration)
    ito_omega_p = 1.5 * eV_to_meep_freq  
    ito_gamma_d = 0.1 * eV_to_meep_freq
    ito_sigma_d = 0.05  # weak contribution
    
    # Lorentz for UV absorption edge
    l1_omega = 4.0 * eV_to_meep_freq
    l1_gamma = 0.5 * eV_to_meep_freq
    l1_sigma = 0.3
    
    susceptibilities = [
        mp.DrudeSusceptibility(frequency=ito_omega_p, gamma=ito_gamma_d, sigma=ito_sigma_d),
        mp.LorentzianSusceptibility(frequency=l1_omega, gamma=l1_gamma, sigma=l1_sigma)
    ]
    
    print(f"    ε_inf={ito_eps_inf:.2f} (n_inf≈{np.sqrt(ito_eps_inf):.2f})")
    
    return mp.Medium(epsilon=ito_eps_inf, E_susceptibilities=susceptibilities)

# Load Aluminum data
print("\nLoading Aluminum data from stage0_al_permittivity.csv...")
aluminum = None
try:
    al_data = np.loadtxt('stage0_al_permittivity.csv', delimiter=',', skiprows=1)
    al_wl = al_data[:, 0]  # wavelength in nm
    al_eps_real = al_data[:, 1]
    al_eps_imag = al_data[:, 2]
    
    # Filter to simulation range (400-700 nm with some margin)
    mask = (al_wl >= 350) & (al_wl <= 750)
    al_wl_fit = al_wl[mask]
    al_eps_real_fit = al_eps_real[mask]
    al_eps_imag_fit = al_eps_imag[mask]
    
    print(f"  Loaded {len(al_wl)} points, using {len(al_wl_fit)} in range 350-750 nm")
    print(f"  ε_real range: [{al_eps_real_fit.min():.1f}, {al_eps_real_fit.max():.1f}]")
    print(f"  ε_imag range: [{al_eps_imag_fit.min():.1f}, {al_eps_imag_fit.max():.1f}]")
    
    # Fit Drude-Lorentz model
    n_poles_al = 4
    al_params, al_eps_fit, al_rms = fit_drude_lorentz(
        al_wl_fit, al_eps_real_fit, al_eps_imag_fit, 
        n_poles=n_poles_al, material_name="Aluminum"
    )
    
    aluminum = create_meep_medium(al_params, n_poles_al - 1)
    print(f"  Created Meep Medium with 1 Drude + {n_poles_al-1} Lorentz terms")
    
except Exception as e:
    print(f"  WARNING: Could not load Al data: {e}")
    aluminum = create_aluminum_fallback()

# Load ITO data
print("\nLoading ITO data from stage0_ito_permittivity.csv...")
ito = None
try:
    ito_data = np.loadtxt('stage0_ito_permittivity.csv', delimiter=',', skiprows=1)
    ito_wl = ito_data[:, 0]  # wavelength in nm
    ito_eps_real = ito_data[:, 1]
    ito_eps_imag = ito_data[:, 2]
    
    # Filter to simulation range
    mask = (ito_wl >= 350) & (ito_wl <= 750)
    ito_wl_fit = ito_wl[mask]
    ito_eps_real_fit = ito_eps_real[mask]
    ito_eps_imag_fit = ito_eps_imag[mask]
    
    print(f"  Loaded {len(ito_wl)} points, using {len(ito_wl_fit)} in range 350-750 nm")
    
    # Check if ITO is nearly non-dispersive in this range
    eps_real_var = np.std(ito_eps_real_fit) / np.mean(np.abs(ito_eps_real_fit))
    eps_imag_mean = np.mean(np.abs(ito_eps_imag_fit))
    
    if eps_real_var < 0.1 and eps_imag_mean < 0.5:
        # Use average constant value
        ito_eps_avg = np.mean(ito_eps_real_fit)
        ito = mp.Medium(epsilon=ito_eps_avg)
        print(f"  ITO nearly non-dispersive, using constant ε={ito_eps_avg:.3f}")
    else:
        # Fit Drude-Lorentz
        n_poles_ito = 3
        ito_params, ito_eps_fit, ito_rms = fit_drude_lorentz(
            ito_wl_fit, ito_eps_real_fit, ito_eps_imag_fit,
            n_poles=n_poles_ito, material_name="ITO"
        )
        ito = create_meep_medium(ito_params, n_poles_ito - 1)
        print(f"  Created Meep Medium with 1 Drude + {n_poles_ito-1} Lorentz terms")
        
except Exception as e:
    print(f"  WARNING: Could not load ITO data: {e}")
    ito = create_ito_fallback()

# ═══════════════════════════════════════════════════════════════════════
# GEOMETRY CONSTRUCTION
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Setting up geometry ---")

# Cell
cell = mp.Vector3(sx, sy, sz)

# PML only in z direction (periodic in x,y)
pml_layers = [mp.PML(thickness=pml_thickness, direction=mp.Z)]

# Geometry: glass substrate, ITO layer, Al disk
geometry = [
    # Glass substrate (semi-infinite, extends from bottom)
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, glass_thickness),
        center=mp.Vector3(0, 0, glass_center_z),
        material=glass
    ),
    # ITO layer on top of glass
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, ito_thickness),
        center=mp.Vector3(0, 0, ito_center_z),
        material=ito
    ),
    # Al nanodisk on top of ITO
    mp.Cylinder(
        radius=disk_radius,
        height=disk_height,
        center=mp.Vector3(0, 0, disk_center_z),
        axis=mp.Vector3(0, 0, 1),
        material=aluminum
    )
]

print(f"Geometry objects: {len(geometry)}")
print(f"  Glass: z={glass_center_z-glass_thickness/2:.2f} to {glass_center_z+glass_thickness/2:.2f}")
print(f"  ITO: z={ito_center_z-ito_thickness/2:.3f} to {ito_center_z+ito_thickness/2:.3f}")
print(f"  Al disk: z={disk_center_z-disk_height/2:.3f} to {disk_center_z+disk_height/2:.3f}")

# ═══════════════════════════════════════════════════════════════════════
# SOURCE SETUP
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Setting up source ---")

sources = [
    mp.Source(
        src=mp.GaussianSource(fcen, fwidth=fwidth),
        component=mp.Ex,
        center=mp.Vector3(0, 0, src_z),
        size=mp.Vector3(sx, sy, 0)
    )
]

print(f"Source: Gaussian pulse, Ex polarized")
print(f"  Center frequency: {fcen:.3f} (λ={1/fcen*1e3:.0f} nm)")
print(f"  Width: {fwidth:.3f} (covers ~{1/(fcen+fwidth/2)*1e3:.0f}-{1/(fcen-fwidth/2)*1e3:.0f} nm)")
print(f"  Position: z={src_z}")

# ═══════════════════════════════════════════════════════════════════════
# SYMMETRIES
# ═══════════════════════════════════════════════════════════════════════

# For Ex polarized source:
# - Ex is ODD under x-reflection → phase = -1
# - Ex is EVEN under y-reflection → phase = +1
symmetries = [
    mp.Mirror(mp.X, phase=-1),
    mp.Mirror(mp.Y, phase=+1)
]
print(f"\nSymmetries: X-mirror (phase=-1), Y-mirror (phase=+1)")
print("  → 4x speedup from symmetry exploitation")

# ═══════════════════════════════════════════════════════════════════════
# FLUX MONITOR REGIONS
# ═══════════════════════════════════════════════════════════════════════

trans_region = mp.FluxRegion(
    center=mp.Vector3(0, 0, trans_z),
    size=mp.Vector3(sx, sy, 0)
)

# Reflection monitor - no weight parameter needed
# The sign will be handled in post-processing per Meep convention
refl_region = mp.FluxRegion(
    center=mp.Vector3(0, 0, refl_z),
    size=mp.Vector3(sx, sy, 0)
)

print(f"\nFlux monitors:")
print(f"  Transmission: z={trans_z} (in glass, above bottom PML)")
print(f"  Reflection: z={refl_z} (between source z={src_z} and structure)")
print(f"  Frequency points: {nfreq}")

# Decay monitoring point (in free space, away from structure)
decay_point = mp.Vector3(0, 0, trans_z)

# ═══════════════════════════════════════════════════════════════════════
# REFERENCE RUN (WITHOUT STRUCTURE)
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "="*60)
print("PASS 1: Reference simulation (no Al disk)")
print("="*60)

# Reference geometry: substrate + ITO only (no disk)
geometry_ref = [
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, glass_thickness),
        center=mp.Vector3(0, 0, glass_center_z),
        material=glass
    ),
    mp.Block(
        size=mp.Vector3(mp.inf, mp.inf, ito_thickness),
        center=mp.Vector3(0, 0, ito_center_z),
        material=ito
    )
]

sim_ref = mp.Simulation(
    cell_size=cell,
    geometry=geometry_ref,
    sources=sources,
    resolution=resolution,
    boundary_layers=pml_layers,
    symmetries=symmetries,
    k_point=mp.Vector3()  # Normal incidence (k=0)
)

# Add flux monitors
flux_trans_ref = sim_ref.add_flux(fcen, fwidth, nfreq, trans_region)
flux_refl_ref = sim_ref.add_flux(fcen, fwidth, nfreq, refl_region)

# Run reference simulation
print("Running reference simulation...")
ref_start = datetime.now()

sim_ref.run(until_after_sources=mp.stop_when_fields_decayed(50, mp.Ex, decay_point, decay_by))

ref_time = (datetime.now() - ref_start).total_seconds()
print(f"Reference simulation completed in {ref_time:.1f} seconds")

# Save reference flux data
ref_trans_flux = np.array(mp.get_fluxes(flux_trans_ref))
ref_refl_data = sim_ref.get_flux_data(flux_refl_ref)
freqs = np.array(mp.get_flux_freqs(flux_trans_ref))

print(f"Frequency range: {freqs.min():.3f} to {freqs.max():.3f} ({1/freqs.max()*1e3:.0f}-{1/freqs.min()*1e3:.0f} nm)")
print(f"Reference transmission flux range: [{ref_trans_flux.min():.3e}, {ref_trans_flux.max():.3e}]")

# ═══════════════════════════════════════════════════════════════════════
# MAIN RUN (WITH STRUCTURE)
# ═══════════════════════════════════════════════════════════════════════

print("\n" + "="*60)
print("PASS 2: Main simulation (with Al disk)")
print("="*60)

sim = mp.Simulation(
    cell_size=cell,
    geometry=geometry,
    sources=sources,
    resolution=resolution,
    boundary_layers=pml_layers,
    symmetries=symmetries,
    k_point=mp.Vector3()
)

# Add flux monitors
flux_trans = sim.add_flux(fcen, fwidth, nfreq, trans_region)
flux_refl = sim.add_flux(fcen, fwidth, nfreq, refl_region)

# Load reference reflection data for proper reflection calculation
# This subtracts the incident flux, leaving only reflected flux
sim.load_minus_flux_data(flux_refl, ref_refl_data)

# Run main simulation
print("Running main simulation...")
main_start = datetime.now()

sim.run(until_after_sources=mp.stop_when_fields_decayed(50, mp.Ex, decay_point, decay_by))

main_time = (datetime.now() - main_start).total_seconds()
print(f"Main simulation completed in {main_time:.1f} seconds")

# ═══════════════════════════════════════════════════════════════════════
# DATA EXTRACTION AND NORMALIZATION
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Extracting and normalizing data ---")

# Get flux values
struct_trans_flux = np.array(mp.get_fluxes(flux_trans))
struct_refl_flux = np.array(mp.get_fluxes(flux_refl))

# Normalized transmission
T = struct_trans_flux / ref_trans_flux

# ═══════════════════════════════════════════════════════════════════════
# FIXED: Reflection sign convention
# ═══════════════════════════════════════════════════════════════════════
# After load_minus_flux_data, the reflection flux has opposite sign from
# what we want. This is the standard Meep convention - we need to negate it.
# See Meep tutorial: https://meep.readthedocs.io/en/latest/Python_Tutorials/Basics/#transmittance-spectrum-of-a-waveguide-bend
# The reflected power is: R = -struct_refl_flux / ref_trans_flux
R = -struct_refl_flux / ref_trans_flux

print(f"Applied reflection sign fix: R = -struct_refl_flux / ref_trans_flux")

# Convert frequency to wavelength (nm)
wavelengths_nm = 1000 / freqs  # nm (since a_unit = 1 µm)

# Validate results for NaN/Inf
def validate_array(arr, name):
    """Check array for NaN/Inf and exit with error if found."""
    if np.any(np.isnan(arr)):
        print(f"ERROR: NaN values detected in {name}")
        print(f"  Shape: {arr.shape}, NaN count: {np.sum(np.isnan(arr))}")
        sys.exit(1)
    if np.any(np.isinf(arr)):
        print(f"ERROR: Inf values detected in {name}")
        print(f"  Shape: {arr.shape}, Inf count: {np.sum(np.isinf(arr))}")
        sys.exit(1)
    print(f"  {name}: OK (range: [{arr.min():.4f}, {arr.max():.4f}])")

print("\nValidating results:")
validate_array(wavelengths_nm, "wavelengths")
validate_array(T, "transmission")
validate_array(R, "reflection")

# Check for unphysical values
if np.any(T < -0.01) or np.any(T > 1.5):
    print(f"WARNING: Transmission values outside physical range [0, 1]: [{T.min():.3f}, {T.max():.3f}]")
if np.any(R < -0.01) or np.any(R > 1.5):
    print(f"WARNING: Reflection values outside physical range [0, 1]: [{R.min():.3f}, {R.max():.3f}]")

# Energy conservation check
T_plus_R = T + R
print(f"\nEnergy conservation check (T+R):")
print(f"  Range: [{T_plus_R.min():.4f}, {T_plus_R.max():.4f}]")
print(f"  Mean: {T_plus_R.mean():.4f}")
if np.any(T_plus_R > 1.05):
    print(f"  WARNING: T+R > 1 indicates numerical issues")
if np.any(T_plus_R < 0.5):
    print(f"  NOTE: T+R < 1 indicates absorption (expected for Al)")

# Filter to 400-700 nm range for analysis
mask_visible = (wavelengths_nm >= 400) & (wavelengths_nm <= 700)
wl_vis = wavelengths_nm[mask_visible]
T_vis = T[mask_visible]
R_vis = R[mask_visible]

# Find transmission minimum (resonance)
min_idx = np.argmin(T_vis)
resonance_wl = wl_vis[min_idx]
resonance_T = T_vis[min_idx]
resonance_R = R_vis[min_idx]

# Calculate extinction
extinction = 1 - T_vis
extinction_max = extinction.max()
extinction_max_wl = wl_vis[np.argmax(extinction)]

print(f"\nResonance characteristics:")
print(f"  Transmission minimum at: {resonance_wl:.1f} nm")
print(f"  Transmission minimum: {resonance_T:.4f}")
print(f"  Reflection at resonance: {resonance_R:.4f}")
print(f"  T + R at resonance: {resonance_T + resonance_R:.4f}")
print(f"  Absorption at resonance: {1 - resonance_T - resonance_R:.4f}")
print(f"\nExtinction:")
print(f"  Maximum extinction: {extinction_max:.4f} ({extinction_max*100:.1f}%)")
print(f"  Maximum extinction at: {extinction_max_wl:.1f} nm")

# ═══════════════════════════════════════════════════════════════════════
# OUTPUT AND PLOTTING
# ═══════════════════════════════════════════════════════════════════════

print("\n--- Saving results ---")

# Prepare output data
output_data = np.column_stack([wavelengths_nm, freqs, T, R])

# Save CSV with metadata header
csv_filename = "antosiewicz2012_stage1_Fig_bare_disk_spectra_transmission.csv"
header = f"""# Stage: stage1_bare_disk_single
# Target: Fig_bare_disk_spectra - Bare Al nanodisk transmission
# Generated: {datetime.now().isoformat()}
# Parameters:
#   Disk diameter: 140 nm
#   Disk height: 40 nm
#   Period: 320 nm (gap = 180 nm)
#   ITO thickness: 30 nm
#   Resolution: {resolution} pts/µm
#   Unit system: a_unit = {a_unit} m
# Resonance: λ = {resonance_wl:.1f} nm, T_min = {resonance_T:.4f}
# Maximum extinction: {extinction_max*100:.1f}% at λ = {extinction_max_wl:.1f} nm
# Fix applied: R = -struct_refl_flux / ref_trans_flux (Meep sign convention)
#
# wavelength_nm,frequency_meep,transmission,reflection"""

np.savetxt(csv_filename, output_data, header=header, delimiter=',', 
           fmt=['%.2f', '%.6f', '%.6f', '%.6f'], comments='')
print(f"Saved: {csv_filename}")

# Create figure matching paper format
plt.figure(figsize=(8, 6))

# Plot transmission spectrum
plt.plot(wavelengths_nm, T, 'b-', linewidth=1.5, label='Transmission')
plt.plot(wavelengths_nm, R, 'r--', linewidth=1.5, label='Reflection')

# Also plot absorption (1-T-R)
A = 1 - T - R
plt.plot(wavelengths_nm, A, 'g:', linewidth=1.5, label='Absorption')

# Mark resonance
plt.axvline(x=resonance_wl, color='gray', linestyle=':', alpha=0.7)
plt.scatter([resonance_wl], [resonance_T], color='blue', s=50, zorder=5)
plt.annotate(f'λ={resonance_wl:.0f} nm\nT={resonance_T:.3f}', 
             xy=(resonance_wl, resonance_T), 
             xytext=(resonance_wl+50, resonance_T+0.1),
             fontsize=9, ha='left',
             arrowprops=dict(arrowstyle='->', color='gray', alpha=0.7))

plt.xlabel('Wavelength (nm)', fontsize=12)
plt.ylabel('T / R / A', fontsize=12)
plt.title('Stage1 – Bare Al Nanodisk Spectrum – Target: Fig_bare_disk_spectra', fontsize=11)
plt.xlim(400, 700)
plt.ylim(0, 1.0)
plt.legend(loc='upper right', fontsize=10)
plt.grid(True, alpha=0.3)

plt.tight_layout()
png_filename = "antosiewicz2012_stage1_Fig_bare_disk_spectra_transmission.png"
plt.savefig(png_filename, dpi=200, bbox_inches='tight')
plt.close()
print(f"Saved: {png_filename}")

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

total_time = (datetime.now() - start_time).total_seconds()

result_summary = {
    "status": "completed",
    "stage_id": "stage1_bare_disk_single",
    "output_files": {
        "data": [csv_filename],
        "plots": [png_filename]
    },
    "key_results": {
        "resonance_wavelength_nm": float(resonance_wl),
        "transmission_minimum": float(resonance_T),
        "reflection_at_resonance": float(resonance_R),
        "absorption_at_resonance": float(1 - resonance_T - resonance_R),
        "T_plus_R_at_resonance": float(resonance_T + resonance_R),
        "maximum_extinction": float(extinction_max),
        "maximum_extinction_wavelength_nm": float(extinction_max_wl),
        "wavelength_range_nm": [float(wavelengths_nm.min()), float(wavelengths_nm.max())],
        "T_range": [float(T.min()), float(T.max())],
        "R_range": [float(R.min()), float(R.max())]
    },
    "runtime_seconds": total_time,
    "breakdown": {
        "reference_run_seconds": ref_time,
        "main_run_seconds": main_time
    },
    "simulation_parameters": {
        "resolution": resolution,
        "cell_size_um": [sx, sy, sz],
        "disk_diameter_nm": 140,
        "disk_height_nm": 40,
        "period_nm": 320,
        "ito_thickness_nm": 30,
        "source_z": src_z,
        "reflection_monitor_z": refl_z,
        "transmission_monitor_z": trans_z
    },
    "fixes_applied": [
        "FIXED: R = -struct_refl_flux / ref_trans_flux (Meep sign convention for reflection)",
        "Reflection monitor at z=0.5 (between source and structure)",
        "Robust Drude-Lorentz fallback for Al (Rakic 1998)",
        "Dispersive fallback for ITO"
    ],
    "meep_version": mp.__version__ if hasattr(mp, '__version__') else "unknown"
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)

print(f"\n=== Simulation complete ===")
print(f"Total runtime: {total_time:.1f} seconds ({total_time/60:.1f} minutes)")
print(f"Output files: {csv_filename}, {png_filename}")
