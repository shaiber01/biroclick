#!/usr/bin/env python3
"""
Stage: stage0_material_validation
Target: Fig 2a (TDBC absorption spectrum)
Description: Analytical material property validation for TDBC, Al, ITO, and glass
             used in Al nanodisk-TDBC strong coupling study.
Generated by: CodeGeneratorAgent
"""

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import json
import os

# ═══════════════════════════════════════════════════════════════════════
# UNIT SYSTEM (from design["unit_system"])
# ═══════════════════════════════════════════════════════════════════════

# Characteristic length - READ FROM DESIGN
a_unit = 1e-9  # design["unit_system"]["characteristic_length_m"] = 1e-9 (1 nm)

print(f"=== Stage 0: Material Validation ===")
print(f"Unit system: a_unit = {a_unit} m ({a_unit*1e9:.1f} nm)")
print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print()

# ═══════════════════════════════════════════════════════════════════════
# PHYSICAL CONSTANTS
# ═══════════════════════════════════════════════════════════════════════

c_light = 2.998e8  # Speed of light (m/s)
hbar = 1.0545718e-34  # Reduced Planck constant (J·s)
eV_to_J = 1.60218e-19  # Electron-volt to Joule conversion

# ═══════════════════════════════════════════════════════════════════════
# WAVELENGTH/ENERGY GRID
# ═══════════════════════════════════════════════════════════════════════

# Define wavelength range (400-800 nm as specified)
wl_min_nm = 400
wl_max_nm = 800
n_points = 500

wavelengths_nm = np.linspace(wl_min_nm, wl_max_nm, n_points)
wavelengths_m = wavelengths_nm * 1e-9

# Convert to angular frequency (rad/s)
omega = 2 * np.pi * c_light / wavelengths_m

# Convert to energy (eV)
energy_eV = hbar * omega / eV_to_J

print(f"Wavelength range: {wl_min_nm}-{wl_max_nm} nm ({n_points} points)")
print(f"Energy range: {energy_eV.min():.3f}-{energy_eV.max():.3f} eV")
print()

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 1: TDBC J-AGGREGATE (Lorentzian oscillator model)
# ═══════════════════════════════════════════════════════════════════════

print("--- Computing TDBC permittivity (Lorentzian model) ---")

# Parameters from paper (Eq. in Methods section)
# ε(ω) = ε∞ + f·ωX²/(ωX² - ω² - i·γX·ω)
eps_inf_tdbc = 2.56  # High-frequency dielectric constant
omega_X = 3.22e15  # Exciton resonance frequency (rad/s) → ~2.12 eV
gamma_X = 2.45e13  # Damping rate (rad/s)
f_osc = 0.45  # Oscillator strength

# Convert parameters to eV for reporting
omega_X_eV = hbar * omega_X / eV_to_J
gamma_X_eV = hbar * gamma_X / eV_to_J
resonance_wavelength_nm = 2 * np.pi * c_light / omega_X * 1e9

print(f"  ε∞ = {eps_inf_tdbc}")
print(f"  ωX = {omega_X:.3e} rad/s = {omega_X_eV:.4f} eV")
print(f"  Resonance wavelength: {resonance_wavelength_nm:.1f} nm")
print(f"  γX = {gamma_X:.3e} rad/s = {gamma_X_eV:.4f} eV")
print(f"  Oscillator strength f = {f_osc}")

# Compute complex permittivity using Lorentzian formula
# ε(ω) = ε∞ + f·ωX²/(ωX² - ω² - i·γX·ω)
numerator = f_osc * omega_X**2
denominator = omega_X**2 - omega**2 - 1j * gamma_X * omega

epsilon_tdbc = eps_inf_tdbc + numerator / denominator

# Extract real and imaginary parts
eps_real_tdbc = np.real(epsilon_tdbc)
eps_imag_tdbc = np.imag(epsilon_tdbc)

# Compute complex refractive index: n + ik = sqrt(ε)
n_complex_tdbc = np.sqrt(epsilon_tdbc)
n_tdbc = np.real(n_complex_tdbc)
k_tdbc = np.imag(n_complex_tdbc)

# Absorption coefficient α = 2ωk/c (1/m)
alpha_tdbc = 2 * omega * k_tdbc / c_light

# ═══════════════════════════════════════════════════════════════════════
# TDBC LINEWIDTH ANALYSIS (addressing the discrepancy)
# ═══════════════════════════════════════════════════════════════════════

print()
print("--- TDBC Linewidth Analysis ---")

# Find peak of imaginary permittivity (absorption)
peak_idx = np.argmax(eps_imag_tdbc)
peak_energy = energy_eV[peak_idx]
peak_wavelength = wavelengths_nm[peak_idx]
peak_value = eps_imag_tdbc[peak_idx]

print(f"  ε'' peak position: {peak_energy:.4f} eV ({peak_wavelength:.1f} nm)")

# Calculate FWHM of ε'' spectrum
half_max = peak_value / 2
above_half = eps_imag_tdbc >= half_max

# Find left and right half-max points
indices = np.where(above_half)[0]
if len(indices) > 1:
    left_idx = indices[0]
    right_idx = indices[-1]
    
    # Interpolate for better accuracy
    # Left side
    if left_idx > 0:
        left_energy = np.interp(half_max, 
                                [eps_imag_tdbc[left_idx-1], eps_imag_tdbc[left_idx]],
                                [energy_eV[left_idx-1], energy_eV[left_idx]])
    else:
        left_energy = energy_eV[left_idx]
    
    # Right side
    if right_idx < len(energy_eV) - 1:
        right_energy = np.interp(half_max,
                                 [eps_imag_tdbc[right_idx+1], eps_imag_tdbc[right_idx]],
                                 [energy_eV[right_idx+1], energy_eV[right_idx]])
    else:
        right_energy = energy_eV[right_idx]
    
    fwhm_computed = abs(right_energy - left_energy)
else:
    fwhm_computed = 2 * gamma_X_eV  # Fallback

print(f"  Computed FWHM from ε'' spectrum: {fwhm_computed:.4f} eV")
print(f"  Expected from ℏγX: {gamma_X_eV:.4f} eV (half-width at half-max)")
print(f"  Paper-stated linewidth: ~0.066 eV")
print()

# Theoretical FWHM for Lorentzian in energy: FWHM = ℏγX (NOT 2ℏγX)
# For the susceptibility χ(ω) ~ 1/(ω0² - ω² - iγω), the FWHM in ω is γ
# In energy: FWHM_E ≈ ℏγX for narrow resonances
print(f"  Note: For Lorentzian oscillator, FWHM in energy ≈ ℏγ = {gamma_X_eV:.4f} eV")
print(f"  The paper's 0.066 eV may include additional broadening or use a different definition.")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 2: ALUMINUM (Palik tabulated data)
# ═══════════════════════════════════════════════════════════════════════

print()
print("--- Loading Aluminum permittivity (Palik) ---")

al_data_file = "materials/palik_aluminum.csv"
al_data_loaded = False

try:
    if os.path.exists(al_data_file):
        al_data = np.loadtxt(al_data_file, delimiter=',', skiprows=1)
        print(f"  Loaded data from {al_data_file}")
        print(f"  Data shape: {al_data.shape}")
        
        # Expected columns: wavelength_um, n, k OR wavelength_nm, n, k
        if al_data.shape[1] >= 3:
            al_wl_raw = al_data[:, 0]
            al_n_raw = al_data[:, 1]
            al_k_raw = al_data[:, 2]
            
            # Check if wavelength is in microns or nm
            if al_wl_raw.max() < 10:  # Likely microns
                al_wl_nm_raw = al_wl_raw * 1000
            else:
                al_wl_nm_raw = al_wl_raw
            
            print(f"  Wavelength range in file: {al_wl_nm_raw.min():.1f}-{al_wl_nm_raw.max():.1f} nm")
            
            # Sort by wavelength
            sort_idx = np.argsort(al_wl_nm_raw)
            al_wl_nm_raw = al_wl_nm_raw[sort_idx]
            al_n_raw = al_n_raw[sort_idx]
            al_k_raw = al_k_raw[sort_idx]
            
            # Interpolate to our wavelength grid
            n_al = np.interp(wavelengths_nm, al_wl_nm_raw, al_n_raw)
            k_al = np.interp(wavelengths_nm, al_wl_nm_raw, al_k_raw)
            
            # Compute permittivity: ε = (n + ik)²
            n_complex_al = n_al + 1j * k_al
            epsilon_al = n_complex_al**2
            eps_real_al = np.real(epsilon_al)
            eps_imag_al = np.imag(epsilon_al)
            
            al_data_loaded = True
            print(f"  n range: {n_al.min():.3f} to {n_al.max():.3f}")
            print(f"  k range: {k_al.min():.3f} to {k_al.max():.3f}")
            print(f"  ε₁ range: {eps_real_al.min():.1f} to {eps_real_al.max():.1f}")
            
            # Verify plasmonic behavior (ε₁ < 0)
            if np.all(eps_real_al < 0):
                print(f"  ✓ Al supports plasmons (ε₁ < 0) throughout visible range")
            else:
                print(f"  ⚠ Warning: ε₁ not negative everywhere - check wavelength range")
except Exception as e:
    print(f"  Warning: Could not load Al data: {e}")

if not al_data_loaded:
    print("  Using Drude model fallback for Aluminum")
    # Drude model: ε = ε_inf - ωp²/(ω² + iγω)
    eps_inf_al = 1.0
    omega_p_al = 15.0 * eV_to_J / hbar  # Plasma frequency ~15 eV
    gamma_al = 0.1 * eV_to_J / hbar  # Damping ~0.1 eV
    
    epsilon_al = eps_inf_al - omega_p_al**2 / (omega**2 + 1j * gamma_al * omega)
    eps_real_al = np.real(epsilon_al)
    eps_imag_al = np.imag(epsilon_al)
    
    n_complex_al = np.sqrt(epsilon_al)
    n_al = np.real(n_complex_al)
    k_al = np.imag(n_complex_al)
    
    print(f"  Drude model: ωp = 15 eV, γ = 0.1 eV")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 3: ITO (Sopra tabulated data)
# ═══════════════════════════════════════════════════════════════════════

print()
print("--- Loading ITO permittivity (Sopra) ---")

ito_data_file = "materials/sopra_ito.csv"
ito_data_loaded = False

try:
    if os.path.exists(ito_data_file):
        ito_data = np.loadtxt(ito_data_file, delimiter=',', skiprows=1)
        print(f"  Loaded data from {ito_data_file}")
        print(f"  Data shape: {ito_data.shape}")
        
        if ito_data.shape[1] >= 3:
            ito_wl_raw = ito_data[:, 0]
            ito_n_raw = ito_data[:, 1]
            ito_k_raw = ito_data[:, 2]
            
            # Check if wavelength is in microns or nm
            if ito_wl_raw.max() < 10:  # Likely microns
                ito_wl_nm_raw = ito_wl_raw * 1000
            else:
                ito_wl_nm_raw = ito_wl_raw
            
            print(f"  Wavelength range in file: {ito_wl_nm_raw.min():.1f}-{ito_wl_nm_raw.max():.1f} nm")
            
            # Sort by wavelength
            sort_idx = np.argsort(ito_wl_nm_raw)
            ito_wl_nm_raw = ito_wl_nm_raw[sort_idx]
            ito_n_raw = ito_n_raw[sort_idx]
            ito_k_raw = ito_k_raw[sort_idx]
            
            # Interpolate to our wavelength grid
            n_ito = np.interp(wavelengths_nm, ito_wl_nm_raw, ito_n_raw)
            k_ito = np.interp(wavelengths_nm, ito_wl_nm_raw, ito_k_raw)
            
            # Compute permittivity
            n_complex_ito = n_ito + 1j * k_ito
            epsilon_ito = n_complex_ito**2
            eps_real_ito = np.real(epsilon_ito)
            eps_imag_ito = np.imag(epsilon_ito)
            
            ito_data_loaded = True
            print(f"  n range: {n_ito.min():.3f} to {n_ito.max():.3f}")
            print(f"  k range: {k_ito.min():.4f} to {k_ito.max():.4f}")
except Exception as e:
    print(f"  Warning: Could not load ITO data: {e}")

if not ito_data_loaded:
    print("  Using constant n=1.9, k=0.01 fallback for ITO")
    n_ito = np.ones_like(wavelengths_nm) * 1.9
    k_ito = np.ones_like(wavelengths_nm) * 0.01
    epsilon_ito = (n_ito + 1j * k_ito)**2
    eps_real_ito = np.real(epsilon_ito)
    eps_imag_ito = np.imag(epsilon_ito)

# Verify ITO is transparent
if np.mean(k_ito) < 0.1:
    print(f"  ✓ ITO is transparent (k < 0.1) in visible range")

# ═══════════════════════════════════════════════════════════════════════
# MATERIAL 4: GLASS SUBSTRATE (constant n)
# ═══════════════════════════════════════════════════════════════════════

print()
print("--- Glass substrate (constant n) ---")

# From design: ε = 2.2801 → n = sqrt(2.2801) ≈ 1.51
eps_glass = 2.2801
n_glass = np.sqrt(eps_glass)
k_glass = 0.0

print(f"  ε = {eps_glass}")
print(f"  n = {n_glass:.4f}")
print(f"  k = {k_glass}")

# ═══════════════════════════════════════════════════════════════════════
# SAVE DATA FILES
# ═══════════════════════════════════════════════════════════════════════

print()
print("--- Saving data files ---")

# TDBC data
tdbc_data = np.column_stack([
    wavelengths_nm, energy_eV, eps_real_tdbc, eps_imag_tdbc, 
    n_tdbc, k_tdbc, alpha_tdbc
])
tdbc_header = f"""# TDBC J-aggregate permittivity (Lorentzian model)
# Stage: stage0_material_validation
# Generated: {datetime.now().isoformat()}
# Parameters: eps_inf={eps_inf_tdbc}, omega_X={omega_X:.3e} rad/s, gamma_X={gamma_X:.3e} rad/s, f={f_osc}
# Peak energy: {peak_energy:.4f} eV, FWHM: {fwhm_computed:.4f} eV
# wavelength_nm,energy_eV,epsilon_real,epsilon_imag,n,k,absorption_coeff"""
np.savetxt('stage0_TDBC_permittivity.csv', tdbc_data, header=tdbc_header, 
           delimiter=',', fmt='%.6e', comments='')
print(f"  Saved: stage0_TDBC_permittivity.csv")

# Aluminum data
al_data_out = np.column_stack([
    wavelengths_nm, energy_eV, eps_real_al, eps_imag_al, n_al, k_al
])
al_header = f"""# Aluminum permittivity (Palik data{'- LOADED' if al_data_loaded else '- DRUDE FALLBACK'})
# Stage: stage0_material_validation
# Generated: {datetime.now().isoformat()}
# wavelength_nm,energy_eV,epsilon_real,epsilon_imag,n,k"""
np.savetxt('stage0_Al_permittivity.csv', al_data_out, header=al_header,
           delimiter=',', fmt='%.6e', comments='')
print(f"  Saved: stage0_Al_permittivity.csv")

# ITO data
ito_data_out = np.column_stack([
    wavelengths_nm, energy_eV, n_ito, k_ito, eps_real_ito, eps_imag_ito
])
ito_header = f"""# ITO permittivity (Sopra data{'- LOADED' if ito_data_loaded else '- FALLBACK'})
# Stage: stage0_material_validation
# Generated: {datetime.now().isoformat()}
# wavelength_nm,energy_eV,n,k,epsilon_real,epsilon_imag"""
np.savetxt('stage0_ITO_permittivity.csv', ito_data_out, header=ito_header,
           delimiter=',', fmt='%.6e', comments='')
print(f"  Saved: stage0_ITO_permittivity.csv")

# ═══════════════════════════════════════════════════════════════════════
# PLOT 1: TDBC ABSORPTION (Fig 2a comparison)
# ═══════════════════════════════════════════════════════════════════════

print()
print("--- Generating plots ---")

fig1, ax1 = plt.subplots(figsize=(8, 6))

# Normalize absorption (ε'') for comparison to Fig 2a
eps_imag_normalized = eps_imag_tdbc / np.max(eps_imag_tdbc)

ax1.plot(energy_eV, eps_imag_normalized, 'b-', linewidth=2, label='TDBC (Lorentzian model)')
ax1.axvline(x=omega_X_eV, color='r', linestyle='--', alpha=0.5, label=f'ωX = {omega_X_eV:.3f} eV')
ax1.axvline(x=2.1, color='g', linestyle=':', alpha=0.5, label='Paper: 2.1 eV')

# Mark FWHM
ax1.axhline(y=0.5, color='gray', linestyle=':', alpha=0.5)
ax1.annotate(f'FWHM = {fwhm_computed:.3f} eV\n(Paper: ~0.066 eV)', 
             xy=(peak_energy + 0.1, 0.5), fontsize=10)

ax1.set_xlabel('Energy (eV)', fontsize=12)
ax1.set_ylabel('Normalized Absorbance', fontsize=12)
ax1.set_xlim(1.5, 3.0)
ax1.set_ylim(0, 1.1)
ax1.legend(loc='upper right')
ax1.set_title('Stage 0 – TDBC Absorption Spectrum – Target: Fig. 2a', fontsize=12)
ax1.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('stage0_fig2a_TDBC_absorption.png', dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: stage0_fig2a_TDBC_absorption.png")

# ═══════════════════════════════════════════════════════════════════════
# PLOT 2: FOUR-PANEL MATERIAL VALIDATION
# ═══════════════════════════════════════════════════════════════════════

fig2, axes = plt.subplots(2, 2, figsize=(12, 10))

# Panel (a): TDBC permittivity
ax_a = axes[0, 0]
ax_a.plot(wavelengths_nm, eps_real_tdbc, 'b-', linewidth=2, label="ε'")
ax_a.plot(wavelengths_nm, eps_imag_tdbc, 'r-', linewidth=2, label="ε''")
ax_a.axhline(y=0, color='k', linestyle='-', alpha=0.3)
ax_a.axvline(x=resonance_wavelength_nm, color='gray', linestyle='--', alpha=0.5)
ax_a.set_xlabel('Wavelength (nm)')
ax_a.set_ylabel('Permittivity')
ax_a.set_title('(a) TDBC J-aggregate')
ax_a.legend()
ax_a.grid(True, alpha=0.3)
ax_a.set_xlim(400, 800)

# Panel (b): Aluminum permittivity
ax_b = axes[0, 1]
ax_b.plot(wavelengths_nm, eps_real_al, 'b-', linewidth=2, label="ε'")
ax_b.plot(wavelengths_nm, eps_imag_al, 'r-', linewidth=2, label="ε''")
ax_b.axhline(y=0, color='k', linestyle='-', alpha=0.3)
ax_b.set_xlabel('Wavelength (nm)')
ax_b.set_ylabel('Permittivity')
ax_b.set_title(f"(b) Aluminum ({'Palik' if al_data_loaded else 'Drude model'})")
ax_b.legend()
ax_b.grid(True, alpha=0.3)
ax_b.set_xlim(400, 800)

# Panel (c): ITO optical constants
ax_c = axes[1, 0]
ax_c.plot(wavelengths_nm, n_ito, 'b-', linewidth=2, label='n')
ax_c.plot(wavelengths_nm, k_ito, 'r-', linewidth=2, label='k')
ax_c.set_xlabel('Wavelength (nm)')
ax_c.set_ylabel('Refractive index')
ax_c.set_title(f"(c) ITO ({'Sopra' if ito_data_loaded else 'Constant'})")
ax_c.legend()
ax_c.grid(True, alpha=0.3)
ax_c.set_xlim(400, 800)

# Panel (d): TDBC n and k
ax_d = axes[1, 1]
ax_d.plot(wavelengths_nm, n_tdbc, 'b-', linewidth=2, label='n')
ax_d.plot(wavelengths_nm, k_tdbc, 'r-', linewidth=2, label='k')
ax_d.axvline(x=resonance_wavelength_nm, color='gray', linestyle='--', alpha=0.5)
ax_d.set_xlabel('Wavelength (nm)')
ax_d.set_ylabel('Refractive index')
ax_d.set_title('(d) TDBC refractive index')
ax_d.legend()
ax_d.grid(True, alpha=0.3)
ax_d.set_xlim(400, 800)

plt.suptitle('Stage 0 – Material Validation for Al Nanodisk-TDBC Study', fontsize=14)
plt.tight_layout()
plt.savefig('stage0_material_validation.png', dpi=200, bbox_inches='tight')
plt.close()
print(f"  Saved: stage0_material_validation.png")

# ═══════════════════════════════════════════════════════════════════════
# VALIDATION SUMMARY
# ═══════════════════════════════════════════════════════════════════════

print()
print("=" * 60)
print("MATERIAL VALIDATION SUMMARY")
print("=" * 60)

print()
print("TDBC J-aggregate:")
print(f"  • Peak position: {peak_energy:.4f} eV ({peak_wavelength:.1f} nm)")
print(f"  • Paper reference: 2.1 eV (590 nm)")
print(f"  • Deviation: {abs(peak_energy - 2.1)/2.1*100:.1f}%")
print(f"  • Computed FWHM: {fwhm_computed:.4f} eV")
print(f"  • Paper-stated linewidth: ~0.066 eV")
print(f"  • DISCREPANCY: Computed FWHM is ~{fwhm_computed/0.066:.1f}x smaller than paper value")

print()
print("Aluminum:")
print(f"  • Data source: {'Palik' if al_data_loaded else 'Drude fallback'}")
print(f"  • ε₁ range at 400-800nm: {eps_real_al.min():.1f} to {eps_real_al.max():.1f}")
print(f"  • Plasmonic (ε₁ < 0): {'✓ YES' if np.all(eps_real_al < 0) else '✗ NO'}")

print()
print("ITO:")
print(f"  • Data source: {'Sopra' if ito_data_loaded else 'Constant fallback'}")
print(f"  • n at 590 nm: {np.interp(590, wavelengths_nm, n_ito):.3f}")
print(f"  • k at 590 nm: {np.interp(590, wavelengths_nm, k_ito):.4f}")
print(f"  • Transparent: {'✓ YES' if np.mean(k_ito) < 0.1 else '✗ NO'}")

print()
print("Glass:")
print(f"  • n = {n_glass:.4f} (constant)")

# ═══════════════════════════════════════════════════════════════════════
# REPROLAB RESULT SUMMARY (MANDATORY - DO NOT REMOVE)
# ═══════════════════════════════════════════════════════════════════════

import time
end_time = time.time()

result_summary = {
    "status": "completed",
    "stage_id": "stage0_material_validation",
    "output_files": {
        "data": [
            "stage0_TDBC_permittivity.csv",
            "stage0_Al_permittivity.csv", 
            "stage0_ITO_permittivity.csv"
        ],
        "plots": [
            "stage0_fig2a_TDBC_absorption.png",
            "stage0_material_validation.png"
        ]
    },
    "key_results": {
        "tdbc_peak_energy_eV": round(peak_energy, 4),
        "tdbc_peak_wavelength_nm": round(peak_wavelength, 1),
        "tdbc_fwhm_computed_eV": round(fwhm_computed, 4),
        "tdbc_fwhm_paper_eV": 0.066,
        "tdbc_linewidth_discrepancy_factor": round(0.066/fwhm_computed, 2),
        "al_data_source": "palik" if al_data_loaded else "drude_fallback",
        "al_eps1_negative_confirmed": bool(np.all(eps_real_al < 0)),
        "ito_data_source": "sopra" if ito_data_loaded else "constant_fallback",
        "ito_n_at_590nm": round(float(np.interp(590, wavelengths_nm, n_ito)), 3),
        "glass_n": round(n_glass, 4)
    },
    "validation_notes": {
        "tdbc_peak_deviation_pct": round(abs(peak_energy - 2.1)/2.1*100, 1),
        "linewidth_issue": f"Computed FWHM ({fwhm_computed:.4f} eV) differs significantly from paper (0.066 eV). May require γX adjustment or alternate interpretation."
    },
    "meep_version": "N/A (analytical calculation)"
}

print("\n" + "=" * 60)
print("REPROLAB_RESULT_JSON_START")
print(json.dumps(result_summary, indent=2))
print("REPROLAB_RESULT_JSON_END")
print("=" * 60)
